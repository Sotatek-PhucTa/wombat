{
  "address": "0xAaF9f18c642B55593e38F2A90B97E9e26ee38Baa",
  "abi": [
    {
      "inputs": [],
      "name": "ADAPTOR__CONTRACT_NOT_TRUSTED",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ADAPTOR__INVALID_TOKEN",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_hash",
          "type": "bytes32"
        }
      ],
      "name": "ADAPTOR__MESSAGE_ALREADY_DELIVERED",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toChain",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fromAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "minimumToAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sequence",
          "type": "uint256"
        }
      ],
      "name": "BridgeCreditAndSwapForTokens",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "emitterChainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "emitterAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "LogError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "wormholeChainId",
          "type": "uint16"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "adaptorAddress",
          "type": "address"
        }
      ],
      "name": "SetAdaptorAddress",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "emitterAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        }
      ],
      "name": "UnknownEmitter",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "name": "adaptorAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "wormholeChainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "tokenAddr",
          "type": "address"
        }
      ],
      "name": "approveToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "toChain",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fromAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minimumToAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "receiverValue",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deliveryGasLimit",
          "type": "uint256"
        }
      ],
      "name": "bridgeCreditAndSwapForTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "sequence",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "crossChainPool",
      "outputs": [
        {
          "internalType": "contract ICrossChainPool",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "deliveredMessage",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "toChain",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "receiverValue",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "deliveryGasLimit",
          "type": "uint32"
        }
      ],
      "name": "estimateDeliveryFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativePriceQuote",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "targetChainRefundPerGasUnused",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "toChain",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "receiverValue",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "deliveryGasLimit",
          "type": "uint32"
        }
      ],
      "name": "estimateRedeliveryFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativePriceQuote",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "targetChainRefundPerGasUnused",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IWormholeRelayer",
          "name": "_relayer",
          "type": "address"
        },
        {
          "internalType": "contract IWormhole",
          "name": "_wormhole",
          "type": "address"
        },
        {
          "internalType": "contract ICrossChainPool",
          "name": "_crossChainPool",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "payload",
          "type": "bytes"
        },
        {
          "internalType": "bytes[]",
          "name": "",
          "type": "bytes[]"
        },
        {
          "internalType": "bytes32",
          "name": "sourceAddress",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "deliveryHash",
          "type": "bytes32"
        }
      ],
      "name": "receiveWormholeMessages",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "relayer",
      "outputs": [
        {
          "internalType": "contract IWormholeRelayer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        },
        {
          "internalType": "uint64",
          "name": "sequence",
          "type": "uint64"
        },
        {
          "internalType": "uint16",
          "name": "targetChain",
          "type": "uint16"
        },
        {
          "internalType": "uint256",
          "name": "newReceiverValue",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newGasLimit",
          "type": "uint256"
        }
      ],
      "name": "requestResend",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "wormholeChainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "tokenAddr",
          "type": "address"
        }
      ],
      "name": "revokeToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "wormholeChainId",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "setAdaptorAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "validToken",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wormhole",
      "outputs": [
        {
          "internalType": "contract IWormhole",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4d5c105a43f54afae5daf79b656fde009b48c06223a3c743c2f5fa6e805a1fe",
  "receipt": {
    "to": null,
    "from": "0xcB3Bb767104e0b3235520fafB182e005D7efD045",
    "contractAddress": "0xAaF9f18c642B55593e38F2A90B97E9e26ee38Baa",
    "transactionIndex": 81,
    "gasUsed": "1239218",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7db18edc6cdf586992acc4a3345787d02ae9faf328d8af811105fbacad3cf025",
    "transactionHash": "0xe4d5c105a43f54afae5daf79b656fde009b48c06223a3c743c2f5fa6e805a1fe",
    "logs": [],
    "blockNumber": 18018388,
    "cumulativeGasUsed": "8327280",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7dce5a3bfa105f0db0e90b26c525cde5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ADAPTOR__CONTRACT_NOT_TRUSTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ADAPTOR__INVALID_TOKEN\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"ADAPTOR__MESSAGE_ALREADY_DELIVERED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumToAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sequence\",\"type\":\"uint256\"}],\"name\":\"BridgeCreditAndSwapForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emitterChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"emitterAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"wormholeChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adaptorAddress\",\"type\":\"address\"}],\"name\":\"SetAdaptorAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"emitterAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"}],\"name\":\"UnknownEmitter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"adaptorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wormholeChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumToAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deliveryGasLimit\",\"type\":\"uint256\"}],\"name\":\"bridgeCreditAndSwapForTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sequence\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crossChainPool\",\"outputs\":[{\"internalType\":\"contract ICrossChainPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"deliveredMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"deliveryGasLimit\",\"type\":\"uint32\"}],\"name\":\"estimateDeliveryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativePriceQuote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetChainRefundPerGasUnused\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"toChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"receiverValue\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"deliveryGasLimit\",\"type\":\"uint32\"}],\"name\":\"estimateRedeliveryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativePriceQuote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetChainRefundPerGasUnused\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IWormholeRelayer\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"contract IWormhole\",\"name\":\"_wormhole\",\"type\":\"address\"},{\"internalType\":\"contract ICrossChainPool\",\"name\":\"_crossChainPool\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"sourceAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"receiveWormholeMessages\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"contract IWormholeRelayer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"targetChain\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"newReceiverValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newGasLimit\",\"type\":\"uint256\"}],\"name\":\"requestResend\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wormholeChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"revokeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"wormholeChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdaptorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wormhole\",\"outputs\":[{\"internalType\":\"contract IWormhole\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"Paused(address)\":{\"details\":\"Emitted when the pause is triggered by `account`.\"},\"Unpaused(address)\":{\"details\":\"Emitted when the pause is lifted by `account`.\"}},\"kind\":\"dev\",\"methods\":{\"bridgeCreditAndSwapForTokens(address,uint256,uint256,uint256,address,uint256,uint256)\":{\"details\":\"Nonce must be non-zero, otherwise wormhole will revert the message\"},\"estimateDeliveryFee(uint16,uint256,uint32)\":{\"details\":\"Note that this function may fail if the value requested is too large. Using deliveryGasLimit 200000 is typically enough\",\"params\":{\"deliveryGasLimit\":\"gas limit of the callback function on the designated network\",\"receiverValue\":\"target amount of gas token to receive\",\"toChain\":\"wormhole chain ID\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)\":{\"details\":\"core relayer is assumed to be trusted so re-entrancy protection is not required Note: This function should NOT throw; Otherwise it will result in a delivery failure Assumptions to the wormhole relayer:   - The message should deliver typically within 5 minutes   - Unused gas should be refunded to the refundAddress   - The target chain id and target contract address is verified Things to be aware of:   - VAA are not verified, order of message can be changed   - deliveries can potentially performed multiple times (ref: https://book.wormhole.com/technical/evm/relayer.html#delivery-failures)\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"requestResend(uint16,uint64,uint16,uint256,uint256)\":{\"details\":\"Redeliver could actually be invoked permisionless on any of the chain that wormhole supports Delivery fee attached to the txn should be done off-chain via `WormholeAdaptor.estimateRedeliveryFee` to reduce gas cost *** This will only be able to succeed if the following is true **         - (For EVM_V1) newGasLimit >= gas limit of the old instruction         - newReceiverValue >= receiver value of the old instruction         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"stateVariables\":{\"adaptorAddress\":{\"details\":\"wormhole chainId => adaptor address\"},\"deliveredMessage\":{\"details\":\"hash => is message delivered\"}},\"title\":\"WormholeAdaptor\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"approveToken(uint256,address)\":{\"notice\":\"Permisioneed functions\"},\"estimateDeliveryFee(uint16,uint256,uint32)\":{\"notice\":\"Estimate the amount of message value required to deliver a message with given `deliveryGasLimit` and `receiveValue` A buffer should be added to `deliveryGasLimit` in case the amount of gas required is higher than the expectation\"},\"requestResend(uint16,uint64,uint16,uint256,uint256)\":{\"notice\":\"A convinience function to redeliver\"},\"validToken(uint256,address)\":{\"notice\":\"whether the token is valid\"}},\"notice\":\"`WormholeAdaptor` uses the generic relayer of wormhole to send message across different networks\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/wombat-core/pool/WormholeAdaptor.sol\":\"WormholeAdaptor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x4075622496acc77fd6d4de4cc30a8577a744d5c75afad33fdeacf1704d6eda98\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xb82ef33f43b6b96109687d91b39c94573fdccaaa423fe28e8ba0977b31c023e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"contracts/wombat-core/interfaces/IAdaptor.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.5;\\n\\ninterface IAdaptor {\\n    /* Cross-chain functions that is used to initiate a cross-chain message, should be invoked by Pool */\\n    function bridgeCreditAndSwapForTokens(\\n        address toToken,\\n        uint256 toChain,\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external payable returns (uint256 trackingId);\\n}\\n\",\"keccak256\":\"0x20b7cd0daae6456123ac88988a4a93bead4cb3de219fffc31364375f4aa0f75b\",\"license\":\"GPL-3.0\"},\"contracts/wombat-core/interfaces/ICrossChainPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.5;\\n\\ninterface ICrossChainPool {\\n    /**\\n     * @notice Initiate a cross chain swap to swap tokens from a chain to tokens in another chain\\n     * @dev Steps:\\n     * 1. User call `swapTokensForTokensCrossChain` to swap `fromToken` for credit\\n     * 2. CrossChainPool request wormhole adaptor to relay the message to the designated chain\\n     * 3. On the designated chain, wormhole relayer invoke `completeSwapCreditForTokens` to swap credit for `toToken` in the `toChain`\\n     * Note: Amount of `value` attached to this function can be estimated by `WormholeAdaptor.estimateDeliveryFee`\\n     */\\n    function swapTokensForTokensCrossChain(\\n        address fromToken,\\n        address toToken,\\n        uint256 toChain, // wormhole chain ID\\n        uint256 fromAmount,\\n        uint256 minimumCreditAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 receiverValue, // gas to receive at the designated contract\\n        uint256 gasLimit // gas limit for the relayed transaction\\n    ) external payable returns (uint256 creditAmount, uint256 fromTokenFee, uint256 id);\\n\\n    /**\\n     * @notice Swap credit for tokens (same chain)\\n     * @dev In case user has some credit, he/she can use this function to swap credit to tokens\\n     */\\n    function swapCreditForTokens(\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver\\n    ) external returns (uint256 actualToAmount, uint256 toTokenFee);\\n\\n    /**\\n     * @notice Bridge credit and swap it for `toToken` in the `toChain`\\n     * @dev In case user has some credit, he/she can use this function to swap credit to tokens in another network\\n     * Note: Amount of `value` attached to this function can be estimated by `WormholeAdaptor.estimateDeliveryFee`\\n     */\\n    function swapCreditForTokensCrossChain(\\n        address toToken,\\n        uint256 toChain, // wormhole chain ID\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 receiverValue, // gas to receive at the designated contract\\n        uint256 gasLimit // gas limit for the relayed transaction\\n    ) external payable returns (uint256 id);\\n\\n    /*\\n     * Permissioned Functions\\n     */\\n\\n    /**\\n     * @notice Swap credit to tokens; should be called by the adaptor\\n     */\\n    function completeSwapCreditForTokens(\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver\\n    ) external returns (uint256 actualToAmount, uint256 toTokenFee);\\n\\n    function mintCredit(uint256 creditAmount, address receiver) external;\\n}\\n\",\"keccak256\":\"0x1482588cab24b43f83f0e244040b81baaa634f1ffcf8dd7d08e5481cb0b2665b\",\"license\":\"GPL-3.0\"},\"contracts/wombat-core/interfaces/IWormhole.sol\":{\"content\":\"// copied from https://github.com/wormhole-foundation/wormhole/blob/8d63ab50fb7cc80c54fa25b81f764c3a2ee132dc/ethereum/contracts/interfaces/IWormhole.sol\\n// contracts/Messages.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWormhole {\\n    struct GuardianSet {\\n        address[] keys;\\n        uint32 expirationTime;\\n    }\\n\\n    struct Signature {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        uint8 guardianIndex;\\n    }\\n\\n    struct VM {\\n        uint8 version;\\n        uint32 timestamp;\\n        uint32 nonce;\\n        uint16 emitterChainId;\\n        bytes32 emitterAddress;\\n        uint64 sequence;\\n        uint8 consistencyLevel;\\n        bytes payload;\\n\\n        uint32 guardianSetIndex;\\n        Signature[] signatures;\\n\\n        bytes32 hash;\\n    }\\n\\n    struct ContractUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        address newContract;\\n    }\\n\\n    struct GuardianSetUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        GuardianSet newGuardianSet;\\n        uint32 newGuardianSetIndex;\\n    }\\n\\n    struct SetMessageFee {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        uint256 messageFee;\\n    }\\n\\n    struct TransferFees {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n\\n        uint256 amount;\\n        bytes32 recipient;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n    event GuardianSetAdded(uint32 indexed index);\\n\\n    function publishMessage(\\n        uint32 nonce,\\n        bytes memory payload,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    function initialize() external;\\n\\n    function parseAndVerifyVM(bytes calldata encodedVM) external view returns (VM memory vm, bool valid, string memory reason);\\n\\n    function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\\n\\n    function verifySignatures(bytes32 hash, Signature[] memory signatures, GuardianSet memory guardianSet) external pure returns (bool valid, string memory reason);\\n\\n    function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\\n\\n    function quorum(uint numGuardians) external pure returns (uint numSignaturesRequiredForQuorum);\\n\\n    function getGuardianSet(uint32 index) external view returns (GuardianSet memory);\\n\\n    function getCurrentGuardianSetIndex() external view returns (uint32);\\n\\n    function getGuardianSetExpiry() external view returns (uint32);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function messageFee() external view returns (uint256);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function nextSequence(address emitter) external view returns (uint64);\\n\\n    function parseContractUpgrade(bytes memory encodedUpgrade) external pure returns (ContractUpgrade memory cu);\\n\\n    function parseGuardianSetUpgrade(bytes memory encodedUpgrade) external pure returns (GuardianSetUpgrade memory gsu);\\n\\n    function parseSetMessageFee(bytes memory encodedSetMessageFee) external pure returns (SetMessageFee memory smf);\\n\\n    function parseTransferFees(bytes memory encodedTransferFees) external pure returns (TransferFees memory tf);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId) external pure returns (RecoverChainId memory rci);\\n\\n    function submitContractUpgrade(bytes memory _vm) external;\\n\\n    function submitSetMessageFee(bytes memory _vm) external;\\n\\n    function submitNewGuardianSet(bytes memory _vm) external;\\n\\n    function submitTransferFees(bytes memory _vm) external;\\n\\n    function submitRecoverChainId(bytes memory _vm) external;\\n}\",\"keccak256\":\"0x3f4c82f699004f65f3c9f2a7720a12615bb1df61ae61cf2035d1e2537562cad0\",\"license\":\"Apache 2\"},\"contracts/wombat-core/interfaces/IWormholeReceiver.sol\":{\"content\":\"// copied from https://github.com/wormhole-foundation/wormhole/blob/8d63ab50fb7cc80c54fa25b81f764c3a2ee132dc/ethereum/contracts/interfaces/relayer/IWormholeReceiver.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for a contract which can receive Wormhole messages.\\n */\\ninterface IWormholeReceiver {\\n    /**\\n     * @notice When a `send` is performed with this contract as the target, this function will be\\n     *     invoked by the WormholeRelayer contract\\n     *\\n     * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\\n     *\\n     * We also recommend that this function:\\n     *   - Stores all received `deliveryHash`s in a mapping `(bytes32 => bool)`, and\\n     *       on every call, checks that deliveryHash has not already been stored in the\\n     *       map (This is to prevent other users maliciously trying to relay the same message)\\n     *   - Checks that `sourceChain` and `sourceAddress` are indeed who\\n     *       you expect to have requested the calling of `send` or `forward` on the source chain\\n     *\\n     * The invocation of this function corresponding to the `send` request will have msg.value equal\\n     *   to the receiverValue specified in the send request.\\n     *\\n     * If the invocation of this function reverts or exceeds the gas limit\\n     *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\\n     *\\n     * @param payload - an arbitrary message which was included in the delivery by the\\n     *     requester.\\n     * @param additionalVaas - Additional VAAs which were requested to be included in this delivery.\\n     *   They are guaranteed to all be included and in the same order as was specified in the\\n     *     delivery request.\\n     * @param sourceAddress - the (wormhole format) address on the sending chain which requested\\n     *     this delivery.\\n     * @param sourceChain - the wormhole chain ID where this delivery was requested.\\n     * @param deliveryHash - the VAA hash of the deliveryVAA.\\n     *\\n     * NOTE: These signedVaas are NOT verified by the Wormhole core contract prior to being provided\\n     *     to this call. Always make sure `parseAndVerify()` is called on the Wormhole core contract\\n     *     before trusting the content of a raw VAA, otherwise the VAA may be invalid or malicious.\\n     */\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x07deb074cc9b02ba52466b84329b51e7e5c630bac1eebd3d75c4775f40a60130\",\"license\":\"Apache 2\"},\"contracts/wombat-core/interfaces/IWormholeRelayer.sol\":{\"content\":\"// Copied from https://github.com/wormhole-foundation/wormhole/blob/8d63ab50fb7cc80c54fa25b81f764c3a2ee132dc/ethereum/contracts/interfaces/relayer/IWormholeRelayer.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WormholeRelayer\\n * @author \\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to \\n * write and run their own relaying infrastructure\\n * \\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional VAAs) \\n * to a chain and address of their choice.\\n */\\n\\n/**\\n * @notice VaaKey identifies a wormhole message\\n *\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\n * @custom:member sequence Sequence number of the VAA\\n */\\nstruct VaaKey {\\n    uint16 chainId;\\n    bytes32 emitterAddress;\\n    uint64 sequence;\\n}\\n\\ninterface IWormholeRelayerBase {\\n    event SendEvent(\\n        uint64 indexed sequence, uint256 deliveryQuote, uint256 paymentForExtraReceiverValue\\n    );\\n\\n    function getRegisteredWormholeRelayerContract(uint16 chainId) external view returns (bytes32);\\n}\\n\\n/**\\n * @title IWormholeRelayerSend\\n * @notice The interface to request deliveries\\n */\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function \\n     * with `refundChain` and `refundAddress` as parameters\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function \\n     * with `refundChain` and `refundAddress` as parameters\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to \\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver) \\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the  \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n    \\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * This function must be called with `msg.value` equal to \\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue  \\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Performs the same function as a `send`, except:\\n     * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n     * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n     * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n     * \\n     * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n     * be paid to the delivery provider to perform the instruction specified here\\n     * \\n     * Publishes an instruction for the same delivery provider (or default, if the same one doesn't support the new target chain)\\n     * to relay a payload to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and with `msg.value` equal to `receiverValue`\\n     * \\n     * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n     * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n     * >= sum_f [quoteEVMDeliveryPrice(targetChain_f, receiverValue_f, gasLimit_f)]\\n     * \\n     * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n     * \\n     * Any refunds (from leftover gas) from this forward will be paid to the same refundChain and refundAddress specified for the current delivery.\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     */\\n    function forwardPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external payable;\\n\\n    /**\\n     * @notice Performs the same function as a `send`, except:\\n     * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n     * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n     * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n     * \\n     * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n     * be paid to the delivery provider to perform the instruction specified here\\n     * \\n     * Publishes an instruction for the same delivery provider (or default, if the same one doesn't support the new target chain)\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and with `msg.value` equal to `receiverValue`\\n     * \\n     * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n     * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n     * >= sum_f [quoteEVMDeliveryPrice(targetChain_f, receiverValue_f, gasLimit_f)]\\n     * \\n     * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n     * \\n     * Any refunds (from leftover gas) from this forward will be paid to the same refundChain and refundAddress specified for the current delivery.\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     */\\n    function forwardVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable;\\n\\n    /**\\n     * @notice Performs the same function as a `send`, except:\\n     * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n     * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n     * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n     * \\n     * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n     * be paid to the delivery provider to perform the instruction specified here\\n     * \\n     * Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with gas limit `gasLimit` and with `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n     * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n     * >= sum_f [quoteEVMDeliveryPrice(targetChain_f, receiverValue_f, gasLimit_f, deliveryProviderAddress_f) + paymentForExtraReceiverValue_f]\\n     * \\n     * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the  \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     */\\n    function forwardToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable;\\n\\n    /**\\n     * @notice Performs the same function as a `send`, except:\\n     * 1)  Can only be used during a delivery (i.e. in execution of `receiveWormholeMessages`)\\n     * 2)  Is paid for (along with any other calls to forward) by (any msg.value passed in) + (refund leftover from current delivery)\\n     * 3)  Only executes after `receiveWormholeMessages` is completed (and thus does not return a sequence number)\\n     * \\n     * The refund from the delivery currently in progress will not be sent to the user; it will instead\\n     * be paid to the delivery provider to perform the instruction specified here\\n     * \\n     * Publishes an instruction for the delivery provider at `deliveryProviderAddress` \\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain` \\n     * with `msg.value` equal to \\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     * \\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     * \\n     * The following equation must be satisfied (sum_f indicates summing over all forwards requested in `receiveWormholeMessages`):\\n     * (refund amount from current execution of receiveWormholeMessages) + sum_f [msg.value_f]\\n     * >= sum_f [quoteDeliveryPrice(targetChain_f, receiverValue_f, encodedExecutionParameters_f, deliveryProviderAddress_f) + paymentForExtraReceiverValue_f]\\n     * \\n     * The difference between the two sides of the above inequality will be added to `paymentForExtraReceiverValue` of the first forward requested\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue \\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see \\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     */\\n    function forward(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable;\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered \\n     * (e.g. with a different delivery provider)\\n     *\\n     * This function must be called with `msg.value` equal to \\n     * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\n     * \\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     * \\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the \\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the  \\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     * @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resendToEvm(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        uint256 newGasLimit,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered \\n     * \\n     *\\n     * This function must be called with `msg.value` equal to \\n     * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\n     * \\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the \\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     * \\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resend(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        bytes memory newEncodedExecutionParameters,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused, \\n     *         if a refundAddress is specified\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. \\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused, \\n     *         if a refundAddress is specified\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return encodedExecutionInfo encoded information on how the delivery will be executed\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\n     *             (which is the amount of target chain currency that will be refunded per unit of gas unused, \\n     *              if a refundAddress is specified)\\n     */\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        bytes memory encodedExecutionParameters,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n    /**\\n     * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\n     * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\n     * \\n     * @param targetChain in Wormhole Chain ID format\\n     * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\n     *         receiverValue + targetChainAmount\\n     */\\n    function quoteNativeForChain(\\n        uint16 targetChain,\\n        uint256 currentChainAmount,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 targetChainAmount);\\n\\n    /**\\n     * @notice Returns the address of the current default delivery provider\\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\n     *   chain. This must be a contract that implements IDeliveryProvider.\\n     */\\n    function getDefaultDeliveryProvider() external view returns (address deliveryProvider);\\n}\\n\\n/**\\n * @title IWormholeRelayerDelivery\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers \\n */\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\n    enum DeliveryStatus {\\n        SUCCESS,\\n        RECEIVER_FAILURE,\\n        FORWARD_REQUEST_FAILURE,\\n        FORWARD_REQUEST_SUCCESS\\n    }\\n\\n    enum RefundStatus {\\n        REFUND_SENT,\\n        REFUND_FAIL,\\n        CROSS_CHAIN_REFUND_SENT,\\n        CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\n        CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH\\n    }\\n\\n    /**\\n     * @custom:member recipientContract - The target contract address\\n     * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\n     *     ChainID format)\\n     * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\n     *     corresponding to this delivery request\\n     * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\n     *     request\\n     * @custom:member gasUsed - The amount of gas that was used to call your target contract \\n     * @custom:member status:\\n     *   - RECEIVER_FAILURE, if the target contract reverts\\n     *   - SUCCESS, if the target contract doesn't revert and no forwards were requested\\n     *   - FORWARD_REQUEST_FAILURE, if the target contract doesn't revert, forwards were requested,\\n     *       but provided/leftover funds were not sufficient to cover them all\\n     *   - FORWARD_REQUEST_SUCCESS, if the target contract doesn't revert and all forwards are covered\\n     * @custom:member additionalStatusInfo:\\n     *   - If status is SUCCESS or FORWARD_REQUEST_SUCCESS, then this is empty.\\n     *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\n     *       return data (i.e. potentially truncated revert reason information).\\n     *   - If status is FORWARD_REQUEST_FAILURE, this is also the revert data - the reason the forward failed.\\n     *     This will be either an encoded Cancelled, DeliveryProviderReverted, or DeliveryProviderPaymentFailed error\\n     * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\n     *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\n     *     where a cross chain refund is necessary\\n     * @custom:member overridesInfo:\\n     *   - If not an override: empty bytes array\\n     *   - Otherwise: An encoded `DeliveryOverride`\\n     */\\n    event Delivery(\\n        address indexed recipientContract,\\n        uint16 indexed sourceChain,\\n        uint64 indexed sequence,\\n        bytes32 deliveryVaaHash,\\n        DeliveryStatus status,\\n        uint256 gasUsed,\\n        RefundStatus refundStatus,\\n        bytes additionalStatusInfo,\\n        bytes overridesInfo\\n    );\\n\\n    /**\\n     * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\n     * \\n     * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\n     * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\n     *\\n     * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\n     * - the delivery VAA has a valid signature\\n     * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\n     * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)     \\n     * - the instruction's target chain is this chain\\n     * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\n     *\\n     * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\n     *     transaction)\\n     * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\n     *     contract with payload being the encoded delivery instruction container\\n     * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\n     *     should be sent\\n     * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\n     *     an encoded DeliveryOverride struct\\n     */\\n    function deliver(\\n        bytes[] memory encodedVMs,\\n        bytes memory encodedDeliveryVAA,\\n        address payable relayerRefundAddress,\\n        bytes memory deliveryOverrides\\n    ) external payable;\\n}\\n\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\n\\n/*\\n *  Errors thrown by IWormholeRelayer contract\\n */\\n\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\n\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\\n\\nerror RequestedGasLimitTooLow();\\n\\nerror DeliveryProviderDoesNotSupportTargetChain(address relayer, uint16 chainId);\\nerror DeliveryProviderCannotReceivePayment();\\n\\n//When calling `forward()` on the WormholeRelayer if no delivery is in progress\\nerror NoDeliveryInProgress();\\n//When calling `delivery()` a second time even though a delivery is already in progress\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\n//When any other contract but the delivery target calls `forward()` on the WormholeRelayer while a\\n//  delivery is in progress\\nerror ForwardRequestFromWrongAddress(address msgSender, address deliveryTarget);\\n\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\nerror InvalidVaaKeyType(uint8 parsed);\\n\\nerror InvalidDeliveryVaa(string reason);\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\n//  registered WormholeRelayer contract\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\nerror VaaKeysLengthDoesNotMatchVaasLength(uint256 keys, uint256 vaas);\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\nerror RequesterNotWormholeRelayer();\\n\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\nerror ForwardNotSufficientlyFunded(uint256 amountOfFunds, uint256 amountOfFundsNeeded);\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\nerror InvalidOverrideGasLimit();\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\nerror InvalidOverrideReceiverValue();\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\nerror InvalidOverrideRefundPerGasUnused();\\n\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\n// maximum possible refund to the user)\\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\\n\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\n//  are non-zero (duplicated from Utils.sol)\\nerror NotAnEvmAddress(bytes32);\",\"keccak256\":\"0x4655a9c5e05879b6556fb55c5e2da20aa1d3fd7043703ead4c49406d24b5a527\",\"license\":\"Apache 2\"},\"contracts/wombat-core/libraries/Adaptor.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.5;\\n\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\nimport '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\\n\\nimport '../interfaces/IAdaptor.sol';\\nimport '../interfaces/ICrossChainPool.sol';\\n\\nabstract contract Adaptor is\\n    IAdaptor,\\n    Initializable,\\n    OwnableUpgradeable,\\n    ReentrancyGuardUpgradeable,\\n    PausableUpgradeable\\n{\\n    ICrossChainPool public crossChainPool;\\n\\n    uint256 private _used;\\n\\n    /// @notice whether the token is valid\\n    /// @dev wormhole chainId => token address => bool\\n    /// Instead of a security feature, this is a sanity check in case user uses an invalid token address\\n    mapping(uint256 => mapping(address => bool)) public validToken;\\n\\n    uint256[50] private __gap;\\n\\n    event BridgeCreditAndSwapForTokens(\\n        address toToken,\\n        uint256 toChain,\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 sequence\\n    );\\n    event LogError(uint256 emitterChainId, address emitterAddress, bytes data);\\n\\n    error ADAPTOR__CONTRACT_NOT_TRUSTED();\\n    error ADAPTOR__INVALID_TOKEN();\\n\\n    function __Adaptor_init(ICrossChainPool _crossChainPool) internal virtual onlyInitializing {\\n        __Ownable_init();\\n        __ReentrancyGuard_init_unchained();\\n\\n        crossChainPool = _crossChainPool;\\n    }\\n\\n    /**\\n     * @dev Nonce must be non-zero, otherwise wormhole will revert the message\\n     */\\n    function bridgeCreditAndSwapForTokens(\\n        address toToken,\\n        uint256 toChain,\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 receiverValue,\\n        uint256 deliveryGasLimit\\n    ) external payable override returns (uint256 sequence) {\\n        require(msg.sender == address(crossChainPool), 'Adaptor: not authorized');\\n        _isValidToken(toChain, toToken);\\n\\n        sequence = _bridgeCreditAndSwapForTokens(\\n            toToken,\\n            toChain,\\n            fromAmount,\\n            minimumToAmount,\\n            receiver,\\n            receiverValue,\\n            deliveryGasLimit\\n        );\\n\\n        // (emitterChainID, emitterAddress, sequence) is used to retrive the generated VAA from the Guardian Network and for tracking\\n        emit BridgeCreditAndSwapForTokens(toToken, toChain, fromAmount, minimumToAmount, receiver, sequence);\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    function _bridgeCreditAndSwapForTokens(\\n        address toToken,\\n        uint256 toChain,\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 receiverValue,\\n        uint256 deliveryGasLimit\\n    ) internal virtual returns (uint256 sequence);\\n\\n    function _isValidToken(uint256 chainId, address tokenAddr) internal view {\\n        if (!validToken[chainId][tokenAddr]) revert ADAPTOR__INVALID_TOKEN();\\n    }\\n\\n    function _swapCreditForTokens(\\n        uint256 emitterChainId,\\n        address emitterAddress,\\n        address toToken,\\n        uint256 creditAmount,\\n        uint256 minimumToAmount,\\n        address receiver\\n    ) internal returns (bool success, uint256 amount) {\\n        try crossChainPool.completeSwapCreditForTokens(toToken, creditAmount, minimumToAmount, receiver) returns (\\n            uint256 actualToAmount,\\n            uint256\\n        ) {\\n            return (true, actualToAmount);\\n        } catch (bytes memory reason) {\\n            // TODO: Investigate how can we decode error message from logs\\n            emit LogError(emitterChainId, emitterAddress, reason);\\n            crossChainPool.mintCredit(creditAmount, receiver);\\n\\n            return (false, creditAmount);\\n        }\\n    }\\n\\n    function _encode(\\n        address toToken,\\n        uint256 creditAmount,\\n        uint256 minimumToAmount,\\n        address receiver\\n    ) internal pure returns (bytes memory) {\\n        require(toToken != address(0), 'toToken cannot be zero');\\n        require(receiver != address(0), 'receiver cannot be zero');\\n        require(creditAmount != uint256(0), 'creditAmount cannot be zero');\\n        require(toToken != receiver, 'toToken cannot be receiver');\\n\\n        return abi.encode(toToken, creditAmount, minimumToAmount, receiver);\\n    }\\n\\n    function _decode(\\n        bytes memory encoded\\n    ) internal pure returns (address toToken, uint256 creditAmount, uint256 minimumToAmount, address receiver) {\\n        require(encoded.length == 128, 'byte length must be 128');\\n\\n        (toToken, creditAmount, minimumToAmount, receiver) = abi.decode(encoded, (address, uint256, uint256, address));\\n\\n        require(toToken != address(0), 'toToken cannot be zero');\\n        require(receiver != address(0), 'receiver cannot be zero');\\n\\n        require(creditAmount != uint256(0), 'creditAmount cannot be zero');\\n        require(toToken != receiver, 'toToken cannot be receiver');\\n    }\\n\\n    /**\\n     * Permisioneed functions\\n     */\\n\\n    function approveToken(uint256 wormholeChainId, address tokenAddr) external onlyOwner {\\n        require(!validToken[wormholeChainId][tokenAddr]);\\n        validToken[wormholeChainId][tokenAddr] = true;\\n    }\\n\\n    function revokeToken(uint256 wormholeChainId, address tokenAddr) external onlyOwner {\\n        require(validToken[wormholeChainId][tokenAddr]);\\n        validToken[wormholeChainId][tokenAddr] = false;\\n    }\\n}\\n\",\"keccak256\":\"0xb46ce0dd9a874ac3343179afa1ac29cd777aa99fd8c352412974253959cd76cf\",\"license\":\"GPL-3.0\"},\"contracts/wombat-core/pool/WormholeAdaptor.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.5;\\n\\nimport '../libraries/Adaptor.sol';\\nimport '../interfaces/IWormholeReceiver.sol';\\nimport '../interfaces/IWormholeRelayer.sol';\\nimport '../interfaces/IWormhole.sol';\\n\\n/// @title WormholeAdaptor\\n/// @notice `WormholeAdaptor` uses the generic relayer of wormhole to send message across different networks\\ncontract WormholeAdaptor is IWormholeReceiver, Adaptor {\\n    struct CrossChainPoolData {\\n        uint256 creditAmount;\\n        address toToken;\\n        uint256 minimumToAmount;\\n        address receiver;\\n    }\\n\\n    IWormholeRelayer public relayer;\\n    IWormhole public wormhole;\\n\\n    /// @dev wormhole chainId => adaptor address\\n    mapping(uint16 => address) public adaptorAddress;\\n\\n    /// @dev hash => is message delivered\\n    mapping(bytes32 => bool) public deliveredMessage;\\n\\n    event UnknownEmitter(address emitterAddress, uint16 sourceChain);\\n    event SetAdaptorAddress(uint16 wormholeChainId, address adaptorAddress);\\n\\n    error ADAPTOR__MESSAGE_ALREADY_DELIVERED(bytes32 _hash);\\n\\n    function initialize(\\n        IWormholeRelayer _relayer,\\n        IWormhole _wormhole,\\n        ICrossChainPool _crossChainPool\\n    ) public virtual initializer {\\n        relayer = _relayer;\\n        wormhole = _wormhole;\\n\\n        __Adaptor_init(_crossChainPool);\\n    }\\n\\n    /**\\n     * External/public functions\\n     */\\n\\n    /**\\n     * @notice A convinience function to redeliver\\n     * @dev Redeliver could actually be invoked permisionless on any of the chain that wormhole supports\\n     * Delivery fee attached to the txn should be done off-chain via `WormholeAdaptor.estimateRedeliveryFee` to reduce gas cost\\n     *\\n     * *** This will only be able to succeed if the following is true **\\n     *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function requestResend(\\n        uint16 sourceChain, // wormhole chain ID\\n        uint64 sequence, // wormhole message sequence\\n        uint16 targetChain, // wormhole chain ID\\n        uint256 newReceiverValue,\\n        uint256 newGasLimit\\n    ) external payable {\\n        VaaKey memory deliveryVaaKey = VaaKey(\\n            sourceChain,\\n            _ethAddrToWormholeAddr(address(relayer)), // use the relayer address\\n            sequence\\n        );\\n        relayer.resendToEvm{value: msg.value}(\\n            deliveryVaaKey, // VaaKey memory deliveryVaaKey\\n            targetChain, // uint16 targetChain\\n            newReceiverValue, // uint256 newReceiverValue\\n            newGasLimit, // uint256 newGasLimit\\n            relayer.getDefaultDeliveryProvider() // address newDeliveryProviderAddress\\n        );\\n    }\\n\\n    /**\\n     * Permisioneed functions\\n     */\\n\\n    /**\\n     * @dev core relayer is assumed to be trusted so re-entrancy protection is not required\\n     * Note: This function should NOT throw; Otherwise it will result in a delivery failure\\n     * Assumptions to the wormhole relayer:\\n     *   - The message should deliver typically within 5 minutes\\n     *   - Unused gas should be refunded to the refundAddress\\n     *   - The target chain id and target contract address is verified\\n     * Things to be aware of:\\n     *   - VAA are not verified, order of message can be changed\\n     *   - deliveries can potentially performed multiple times\\n     * (ref: https://book.wormhole.com/technical/evm/relayer.html#delivery-failures)\\n     */\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory /* additionalVaas */,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable override {\\n        // Only the core relayer can invoke this function\\n        // Verify the sender as there are trust assumptions to the generic relayer\\n        require(msg.sender == address(relayer), 'not authorized');\\n\\n        // only accept messages from a trusted chain & contract\\n        // Assumption: the core relayer must verify the target chain ID and target contract address\\n        address sourAddr = _wormholeAddrToEthAddr(sourceAddress);\\n        if (adaptorAddress[sourceChain] != sourAddr) {\\n            emit UnknownEmitter(sourAddr, sourceChain);\\n            return;\\n        }\\n\\n        // Important note: While Wormhole is in beta, the selected RelayProvider can potentially\\n        // reorder, omit, or mix-and-match VAAs if they were to behave maliciously\\n        _recordMessageHash(deliveryHash);\\n\\n        (address toToken, uint256 creditAmount, uint256 minimumToAmount, address receiver) = _decode(payload);\\n\\n        // transfer receiver value to the `receiver`\\n        (bool success, ) = receiver.call{value: msg.value}(new bytes(0));\\n        require(success, 'WormholeAdaptor: failed to send receiver value');\\n\\n        _swapCreditForTokens(sourceChain, sourAddr, toToken, creditAmount, minimumToAmount, receiver);\\n    }\\n\\n    function setAdaptorAddress(uint16 wormholeChainId, address addr) external onlyOwner {\\n        adaptorAddress[wormholeChainId] = addr;\\n        emit SetAdaptorAddress(wormholeChainId, addr);\\n    }\\n\\n    /**\\n     * Internal functions\\n     */\\n\\n    function _recordMessageHash(bytes32 _hash) internal {\\n        // revert if the message is already delivered\\n        if (deliveredMessage[_hash]) revert ADAPTOR__MESSAGE_ALREADY_DELIVERED(_hash);\\n        deliveredMessage[_hash] = true;\\n    }\\n\\n    function _bridgeCreditAndSwapForTokens(\\n        address toToken,\\n        uint256 toChain, // wormhole chain ID\\n        uint256 fromAmount,\\n        uint256 minimumToAmount,\\n        address receiver,\\n        uint256 receiverValue,\\n        uint256 deliveryGasLimit\\n    ) internal override returns (uint256 sequence) {\\n        // Delivery fee attached to the txn is done off-chain via `estimateDeliveryFee` to reduce gas cost\\n        // Unused `deliveryGasLimit` is sent to the `refundAddress` (`receiver`).\\n\\n        require(toChain <= type(uint16).max, 'invalid chain ID');\\n\\n        // (emitterChainID, emitterAddress, sequence) is used to retrive the generated VAA from the Guardian Network and for tracking\\n        sequence = relayer.sendPayloadToEvm{value: msg.value}(\\n            uint16(toChain), // uint16 targetChain\\n            adaptorAddress[uint16(toChain)], // address targetAddress\\n            _encode(toToken, fromAmount, minimumToAmount, receiver), // bytes memory payload\\n            receiverValue, // uint256 receiverValue\\n            deliveryGasLimit, // uint256 gasLimit\\n            uint16(toChain), // uint16 refundChain\\n            receiver // address refundAddress\\n        );\\n    }\\n\\n    /**\\n     * Read-only functions\\n     */\\n\\n    /**\\n     * @notice Estimate the amount of message value required to deliver a message with given `deliveryGasLimit` and `receiveValue`\\n     * A buffer should be added to `deliveryGasLimit` in case the amount of gas required is higher than the expectation\\n     * @param toChain wormhole chain ID\\n     * @param deliveryGasLimit gas limit of the callback function on the designated network\\n     * @param receiverValue target amount of gas token to receive\\n     * @dev Note that this function may fail if the value requested is too large. Using deliveryGasLimit 200000 is typically enough\\n     */\\n    function estimateDeliveryFee(\\n        uint16 toChain,\\n        uint256 receiverValue,\\n        uint32 deliveryGasLimit\\n    ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused) {\\n        return relayer.quoteEVMDeliveryPrice(toChain, receiverValue, deliveryGasLimit);\\n    }\\n\\n    function estimateRedeliveryFee(\\n        uint16 toChain,\\n        uint256 receiverValue,\\n        uint32 deliveryGasLimit\\n    ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused) {\\n        return relayer.quoteEVMDeliveryPrice(toChain, receiverValue, deliveryGasLimit);\\n    }\\n\\n    function _wormholeAddrToEthAddr(bytes32 addr) internal pure returns (address) {\\n        require(address(uint160(uint256(addr))) != address(0), 'addr bytes cannot be zero');\\n        return address(uint160(uint256(addr)));\\n    }\\n\\n    function _ethAddrToWormholeAddr(address addr) internal pure returns (bytes32) {\\n        require(addr != address(0), 'addr cannot be zero');\\n        return bytes32(uint256(uint160(addr)));\\n    }\\n}\\n\",\"keccak256\":\"0xba84d854b8eec4eeefb501cbc111c167ff13efcab12f2f5bf59354acfcd8c9c0\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657611583908161001c8239f35b600080fdfe6040608081526004908136101561001557600080fd5b600091823560e01c80630302c0c41461019d578063529dca3214610b6d57806359cae11714610b055780635c975abb14610ae15780636bc8fa1c14610ab457806371233d3b14610a6f578063715018a614610a045780637b91993f1461075e5780638406c0791461073657806384acd1bb1461070e5780638da5cb5b146106e6578063b1d190a6146106aa578063c0c53b8b146104e6578063d2180e6114610478578063d44f9a7814610262578063d4d7ae7a1461023a578063db4a002f146101a2578063e4b8cff21461019d5763f2fde38b146100f257600080fd5b346101995760203660031901126101995761010b610df4565b91610114610e0a565b6001600160a01b03831615610130578361012d84610e62565b80f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b610c68565b5050346102365780600319360112610236577f60b2a6de152a68b38db6e7945b0f2f93bf6a28523e2e29b7520b39e2f59dfa6f906101de610c52565b61ffff6101e9610dde565b916101f2610e0a565b16908185526101006020526001600160a01b038386209116908173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a180f35b5080fd5b5050346102365781600319360112610236576020906001600160a01b0360c954169051908152f35b50919060a036600319011261023657610279610c52565b926024359167ffffffffffffffff92838116809103610474576044359361ffff90818616809603610470576001600160a01b038060fe541690811561042d57855192606084018481108282111761041a578a9b86918952168452602098898501918483528886019788528851927f24320c9f0000000000000000000000000000000000000000000000000000000084528b848c81895afa938415610410578c9d9c999a9b9c946103cd575b509860e49798998b519c8d9a8b997f8b0301b1000000000000000000000000000000000000000000000000000000008b52511690890152516024880152511660448601526064850152606435608485015260843560a48501521660c483015234905af19081156103c45750610397578280f35b816103b692903d106103bd575b6103ae8183610d43565b810190610f28565b5038808280f35b503d6103a4565b513d85823e3d90fd5b898193999a9295503d8311610409575b6103e78183610d43565b810103126104055751958387168703610405578b97969260e4610324565b8c80fd5b503d6103dd565b8a513d8f823e3d90fd5b60248b60418b634e487b7160e01b835252fd5b606487602088519162461bcd60e51b8352820152601360248201527f616464722063616e6e6f74206265207a65726f000000000000000000000000006044820152fd5b8680fd5b8480fd5b503461019957816003193601126101995735610492610dde565b9061049b610e0a565b80845260cb6020526001600160a01b0383852092169182855260205260ff83852054166104e257835260cb6020528183209083526020528120600160ff1982541617905580f35b8380fd5b5034610199576060366003190112610199578035906001600160a01b0380831680930361047457602435928184168094036106a6576044359182168092036106a65785549360ff94858160081c16159485809661069a575b8015610684575b1561061b575060ff19811660011788558461060a575b5073ffffffffffffffffffffffffffffffffffffffff19918260fe54161760fe55818554161784556105a484875460081c1661059681610eb7565b61059f81610eb7565b610eb7565b6105ad33610e62565b6105bd8654948560081c16610eb7565b600160655560c954161760c9556105d2578280f35b61ff001916825551600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a138808280f35b61ffff19166101011787553861055b565b608490602089519162461bcd60e51b8352820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152fd5b50303b1580156105455750600187831614610545565b5060018783161061053e565b8580fd5b505034610236576020366003190112610236576001600160a01b038160209361ffff6106d4610c52565b16815261010085522054169051908152f35b5050346102365781600319360112610236576020906001600160a01b03603354169051908152f35b5050346102365781600319360112610236576020906001600160a01b0360ff54169051908152f35b5050346102365781600319360112610236576020906001600160a01b0360fe54169051908152f35b50919060e036600319011261023657610775610df4565b6024359260443560643590608435926001600160a01b039485851694858103610199578660c9541633036109c15788835260209960cb8b5288842097808416988986528c5260ff8a86205416156109995761ffff91828c1161095757908c9392918160fe5416928d169182885261010086528c88205416938b15156107f990611421565b6108048b151561146c565b61080f8915156114b7565b61081b8c8c1415611502565b8c516001600160a01b03978816878201908152602081018b9052604081018c9052919097166060820152869060800103601f198101875261085c9087610d43565b818c51968795869485947f4b5ca6f400000000000000000000000000000000000000000000000000000000865285015260248401526044830160e0905260e483016108a691611252565b9060a435606484015260c435608484015260a48301528a60c4830152039134905af191821561094c577f1ef8cdf0233595373c92135e5095395bebb953c655778d5fceb6014d4031526096949260c096949267ffffffffffffffff929161092f575b50169787519485528985015286840152606083015260808201528460a0820152a151908152f35b61094691508b3d8d116103bd576103ae8183610d43565b38610908565b8751903d90823e3d90fd5b6064908d8c519162461bcd60e51b8352820152601060248201527f696e76616c696420636861696e204944000000000000000000000000000000006044820152fd5b5088517f859ce673000000000000000000000000000000000000000000000000000000008152fd5b60648a60208a519162461bcd60e51b8352820152601760248201527f41646170746f723a206e6f7420617574686f72697a65640000000000000000006044820152fd5b8334610a6c5780600319360112610a6c57610a1d610e0a565b806001600160a01b0360335473ffffffffffffffffffffffffffffffffffffffff198116603355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b50346101995781600319360112610199578160209360ff92610a8f610dde565b9035825260cb86526001600160a01b0383832091168252855220541690519015158152f35b5034610199576020366003190112610199578160209360ff92358152610101855220541690519015158152f35b50503461023657816003193601126102365760209060ff6097541690519015158152f35b503461019957816003193601126101995735610b1f610dde565b90610b28610e0a565b80845260cb6020526001600160a01b0383852092169182855260205260ff8385205416156104e257835260cb602052818320908352602052812060ff19815416905580f35b5060a03660031901126101995767ffffffffffffffff813581811161047457610b999036908401610d97565b9260248035908382116104705736602383011215610470578185013594848611610c415750808560051b9351956020968791610bd783880183610d43565b8152019383010193368511610c3d57818301935b858510610c1357886064358961ffff821682036101995761012d916084359160443590610f78565b8435828111610c39578791610c2e8392863691890101610d97565b815201940193610beb565b8980fd5b8780fd5b60418891634e487b7160e01b835252fd5b6004359061ffff82168203610c6357565b600080fd5b34610c63576060366003190112610c635760043561ffff8116809103610c635760443563ffffffff8116809103610c63576064916001600160a01b0360fe5416916040938492835194859384927fc23ee3c30000000000000000000000000000000000000000000000000000000084526004840152602435602484015260448301525afa8015610d38576000918291610d09575b5082519182526020820152f35b9050610d2b9150823d8411610d31575b610d238183610d43565b81019061123c565b38610cfc565b503d610d19565b82513d6000823e3d90fd5b90601f8019910116810190811067ffffffffffffffff821117610d6557604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff8111610d6557601f01601f191660200190565b81601f82011215610c6357803590610dae82610d7b565b92610dbc6040519485610d43565b82845260208383010111610c6357816000926020809301838601378301015290565b602435906001600160a01b0382168203610c6357565b600435906001600160a01b0382168203610c6357565b6001600160a01b03603354163303610e1e57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b603354906001600160a01b03809116918273ffffffffffffffffffffffffffffffffffffffff19821617603355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b15610ebe57565b608460405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152fd5b90816020910312610c63575167ffffffffffffffff81168103610c635790565b3d15610f73573d90610f5982610d7b565b91610f676040519384610d43565b82523d6000602084013e565b606090565b909392936001600160a01b03908160fe541633036111f85781169283156111b45761ffff1692600090848252602094610100865260409782858a862054160361117f578084526101019081885260ff8a8620541661114f5784528652878320805460ff191660011790558451607f190161110c576080858051810103126101995761100486860161140d565b9588860151948061101c608060608a0151990161140d565b1697169361102b851515611421565b61103688151561146c565b6110418615156114b7565b61104d88861415611502565b895182810181811067ffffffffffffffff8211176110f8578b52819052808080348b5af1611079610f48565b501561108f575061108b969750611292565b5050565b60849089519062461bcd60e51b82526004820152602e60248201527f576f726d686f6c6541646170746f723a206661696c656420746f2073656e642060448201527f72656365697665722076616c75650000000000000000000000000000000000006064820152fd5b602483634e487b7160e01b81526041600452fd5b60648689519062461bcd60e51b82526004820152601760248201527f62797465206c656e677468206d757374206265203132380000000000000000006044820152fd5b6024908a51907f488375260000000000000000000000000000000000000000000000000000000082526004820152fd5b50925092505084927f56934552964208d649785e6d47035525594e1ce64c178f178742c347cbf029dc949551928352820152a1565b606460405162461bcd60e51b815260206004820152601960248201527f616464722062797465732063616e6e6f74206265207a65726f000000000000006044820152fd5b606460405162461bcd60e51b815260206004820152600e60248201527f6e6f7420617574686f72697a65640000000000000000000000000000000000006044820152fd5b9190826040910312610c63576020825192015190565b919082519283825260005b84811061127e575050826000602080949584010152601f8019910116010190565b60208183018101518483018201520161125d565b60c954604080517f9630b6600000000000000000000000000000000000000000000000000000000081526001600160a01b039586166004820152602481018790526044810197909752938716606487015293969560009590949291908481806084810103818a6001600160a01b038099165af18791816113ed575b506113df5750907f73f0f2effb21f6d5df0aaf7344e6b67683035497dc33c864140c2d3c64e8756a9161135f611341610f48565b85875194859485521660208401526060878401526060830190611252565b0390a18060c9541692833b1561047457906044859283855196879485937f5b6cfa610000000000000000000000000000000000000000000000000000000085528c60048601521660248401525af180156113d5576113be575b50509190565b67ffffffffffffffff82116110f8575238806113b8565b81513d85823e3d90fd5b975050505050505060019190565b611405919250863d8811610d3157610d238183610d43565b50903861130d565b51906001600160a01b0382168203610c6357565b1561142857565b606460405162461bcd60e51b815260206004820152601660248201527f746f546f6b656e2063616e6e6f74206265207a65726f000000000000000000006044820152fd5b1561147357565b606460405162461bcd60e51b815260206004820152601760248201527f72656365697665722063616e6e6f74206265207a65726f0000000000000000006044820152fd5b156114be57565b606460405162461bcd60e51b815260206004820152601b60248201527f637265646974416d6f756e742063616e6e6f74206265207a65726f00000000006044820152fd5b1561150957565b606460405162461bcd60e51b815260206004820152601a60248201527f746f546f6b656e2063616e6e6f742062652072656365697665720000000000006044820152fdfea264697066735822122062521c88427f321b7a7f83d9032ab7b9391d203ac6427e5fd9cc60d276a97da564736f6c63430008120033",
  "deployedBytecode": "0x6040608081526004908136101561001557600080fd5b600091823560e01c80630302c0c41461019d578063529dca3214610b6d57806359cae11714610b055780635c975abb14610ae15780636bc8fa1c14610ab457806371233d3b14610a6f578063715018a614610a045780637b91993f1461075e5780638406c0791461073657806384acd1bb1461070e5780638da5cb5b146106e6578063b1d190a6146106aa578063c0c53b8b146104e6578063d2180e6114610478578063d44f9a7814610262578063d4d7ae7a1461023a578063db4a002f146101a2578063e4b8cff21461019d5763f2fde38b146100f257600080fd5b346101995760203660031901126101995761010b610df4565b91610114610e0a565b6001600160a01b03831615610130578361012d84610e62565b80f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b8280fd5b610c68565b5050346102365780600319360112610236577f60b2a6de152a68b38db6e7945b0f2f93bf6a28523e2e29b7520b39e2f59dfa6f906101de610c52565b61ffff6101e9610dde565b916101f2610e0a565b16908185526101006020526001600160a01b038386209116908173ffffffffffffffffffffffffffffffffffffffff1982541617905582519182526020820152a180f35b5080fd5b5050346102365781600319360112610236576020906001600160a01b0360c954169051908152f35b50919060a036600319011261023657610279610c52565b926024359167ffffffffffffffff92838116809103610474576044359361ffff90818616809603610470576001600160a01b038060fe541690811561042d57855192606084018481108282111761041a578a9b86918952168452602098898501918483528886019788528851927f24320c9f0000000000000000000000000000000000000000000000000000000084528b848c81895afa938415610410578c9d9c999a9b9c946103cd575b509860e49798998b519c8d9a8b997f8b0301b1000000000000000000000000000000000000000000000000000000008b52511690890152516024880152511660448601526064850152606435608485015260843560a48501521660c483015234905af19081156103c45750610397578280f35b816103b692903d106103bd575b6103ae8183610d43565b810190610f28565b5038808280f35b503d6103a4565b513d85823e3d90fd5b898193999a9295503d8311610409575b6103e78183610d43565b810103126104055751958387168703610405578b97969260e4610324565b8c80fd5b503d6103dd565b8a513d8f823e3d90fd5b60248b60418b634e487b7160e01b835252fd5b606487602088519162461bcd60e51b8352820152601360248201527f616464722063616e6e6f74206265207a65726f000000000000000000000000006044820152fd5b8680fd5b8480fd5b503461019957816003193601126101995735610492610dde565b9061049b610e0a565b80845260cb6020526001600160a01b0383852092169182855260205260ff83852054166104e257835260cb6020528183209083526020528120600160ff1982541617905580f35b8380fd5b5034610199576060366003190112610199578035906001600160a01b0380831680930361047457602435928184168094036106a6576044359182168092036106a65785549360ff94858160081c16159485809661069a575b8015610684575b1561061b575060ff19811660011788558461060a575b5073ffffffffffffffffffffffffffffffffffffffff19918260fe54161760fe55818554161784556105a484875460081c1661059681610eb7565b61059f81610eb7565b610eb7565b6105ad33610e62565b6105bd8654948560081c16610eb7565b600160655560c954161760c9556105d2578280f35b61ff001916825551600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a138808280f35b61ffff19166101011787553861055b565b608490602089519162461bcd60e51b8352820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152fd5b50303b1580156105455750600187831614610545565b5060018783161061053e565b8580fd5b505034610236576020366003190112610236576001600160a01b038160209361ffff6106d4610c52565b16815261010085522054169051908152f35b5050346102365781600319360112610236576020906001600160a01b03603354169051908152f35b5050346102365781600319360112610236576020906001600160a01b0360ff54169051908152f35b5050346102365781600319360112610236576020906001600160a01b0360fe54169051908152f35b50919060e036600319011261023657610775610df4565b6024359260443560643590608435926001600160a01b039485851694858103610199578660c9541633036109c15788835260209960cb8b5288842097808416988986528c5260ff8a86205416156109995761ffff91828c1161095757908c9392918160fe5416928d169182885261010086528c88205416938b15156107f990611421565b6108048b151561146c565b61080f8915156114b7565b61081b8c8c1415611502565b8c516001600160a01b03978816878201908152602081018b9052604081018c9052919097166060820152869060800103601f198101875261085c9087610d43565b818c51968795869485947f4b5ca6f400000000000000000000000000000000000000000000000000000000865285015260248401526044830160e0905260e483016108a691611252565b9060a435606484015260c435608484015260a48301528a60c4830152039134905af191821561094c577f1ef8cdf0233595373c92135e5095395bebb953c655778d5fceb6014d4031526096949260c096949267ffffffffffffffff929161092f575b50169787519485528985015286840152606083015260808201528460a0820152a151908152f35b61094691508b3d8d116103bd576103ae8183610d43565b38610908565b8751903d90823e3d90fd5b6064908d8c519162461bcd60e51b8352820152601060248201527f696e76616c696420636861696e204944000000000000000000000000000000006044820152fd5b5088517f859ce673000000000000000000000000000000000000000000000000000000008152fd5b60648a60208a519162461bcd60e51b8352820152601760248201527f41646170746f723a206e6f7420617574686f72697a65640000000000000000006044820152fd5b8334610a6c5780600319360112610a6c57610a1d610e0a565b806001600160a01b0360335473ffffffffffffffffffffffffffffffffffffffff198116603355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b50346101995781600319360112610199578160209360ff92610a8f610dde565b9035825260cb86526001600160a01b0383832091168252855220541690519015158152f35b5034610199576020366003190112610199578160209360ff92358152610101855220541690519015158152f35b50503461023657816003193601126102365760209060ff6097541690519015158152f35b503461019957816003193601126101995735610b1f610dde565b90610b28610e0a565b80845260cb6020526001600160a01b0383852092169182855260205260ff8385205416156104e257835260cb602052818320908352602052812060ff19815416905580f35b5060a03660031901126101995767ffffffffffffffff813581811161047457610b999036908401610d97565b9260248035908382116104705736602383011215610470578185013594848611610c415750808560051b9351956020968791610bd783880183610d43565b8152019383010193368511610c3d57818301935b858510610c1357886064358961ffff821682036101995761012d916084359160443590610f78565b8435828111610c39578791610c2e8392863691890101610d97565b815201940193610beb565b8980fd5b8780fd5b60418891634e487b7160e01b835252fd5b6004359061ffff82168203610c6357565b600080fd5b34610c63576060366003190112610c635760043561ffff8116809103610c635760443563ffffffff8116809103610c63576064916001600160a01b0360fe5416916040938492835194859384927fc23ee3c30000000000000000000000000000000000000000000000000000000084526004840152602435602484015260448301525afa8015610d38576000918291610d09575b5082519182526020820152f35b9050610d2b9150823d8411610d31575b610d238183610d43565b81019061123c565b38610cfc565b503d610d19565b82513d6000823e3d90fd5b90601f8019910116810190811067ffffffffffffffff821117610d6557604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff8111610d6557601f01601f191660200190565b81601f82011215610c6357803590610dae82610d7b565b92610dbc6040519485610d43565b82845260208383010111610c6357816000926020809301838601378301015290565b602435906001600160a01b0382168203610c6357565b600435906001600160a01b0382168203610c6357565b6001600160a01b03603354163303610e1e57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b603354906001600160a01b03809116918273ffffffffffffffffffffffffffffffffffffffff19821617603355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b15610ebe57565b608460405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152fd5b90816020910312610c63575167ffffffffffffffff81168103610c635790565b3d15610f73573d90610f5982610d7b565b91610f676040519384610d43565b82523d6000602084013e565b606090565b909392936001600160a01b03908160fe541633036111f85781169283156111b45761ffff1692600090848252602094610100865260409782858a862054160361117f578084526101019081885260ff8a8620541661114f5784528652878320805460ff191660011790558451607f190161110c576080858051810103126101995761100486860161140d565b9588860151948061101c608060608a0151990161140d565b1697169361102b851515611421565b61103688151561146c565b6110418615156114b7565b61104d88861415611502565b895182810181811067ffffffffffffffff8211176110f8578b52819052808080348b5af1611079610f48565b501561108f575061108b969750611292565b5050565b60849089519062461bcd60e51b82526004820152602e60248201527f576f726d686f6c6541646170746f723a206661696c656420746f2073656e642060448201527f72656365697665722076616c75650000000000000000000000000000000000006064820152fd5b602483634e487b7160e01b81526041600452fd5b60648689519062461bcd60e51b82526004820152601760248201527f62797465206c656e677468206d757374206265203132380000000000000000006044820152fd5b6024908a51907f488375260000000000000000000000000000000000000000000000000000000082526004820152fd5b50925092505084927f56934552964208d649785e6d47035525594e1ce64c178f178742c347cbf029dc949551928352820152a1565b606460405162461bcd60e51b815260206004820152601960248201527f616464722062797465732063616e6e6f74206265207a65726f000000000000006044820152fd5b606460405162461bcd60e51b815260206004820152600e60248201527f6e6f7420617574686f72697a65640000000000000000000000000000000000006044820152fd5b9190826040910312610c63576020825192015190565b919082519283825260005b84811061127e575050826000602080949584010152601f8019910116010190565b60208183018101518483018201520161125d565b60c954604080517f9630b6600000000000000000000000000000000000000000000000000000000081526001600160a01b039586166004820152602481018790526044810197909752938716606487015293969560009590949291908481806084810103818a6001600160a01b038099165af18791816113ed575b506113df5750907f73f0f2effb21f6d5df0aaf7344e6b67683035497dc33c864140c2d3c64e8756a9161135f611341610f48565b85875194859485521660208401526060878401526060830190611252565b0390a18060c9541692833b1561047457906044859283855196879485937f5b6cfa610000000000000000000000000000000000000000000000000000000085528c60048601521660248401525af180156113d5576113be575b50509190565b67ffffffffffffffff82116110f8575238806113b8565b81513d85823e3d90fd5b975050505050505060019190565b611405919250863d8811610d3157610d238183610d43565b50903861130d565b51906001600160a01b0382168203610c6357565b1561142857565b606460405162461bcd60e51b815260206004820152601660248201527f746f546f6b656e2063616e6e6f74206265207a65726f000000000000000000006044820152fd5b1561147357565b606460405162461bcd60e51b815260206004820152601760248201527f72656365697665722063616e6e6f74206265207a65726f0000000000000000006044820152fd5b156114be57565b606460405162461bcd60e51b815260206004820152601b60248201527f637265646974416d6f756e742063616e6e6f74206265207a65726f00000000006044820152fd5b1561150957565b606460405162461bcd60e51b815260206004820152601a60248201527f746f546f6b656e2063616e6e6f742062652072656365697665720000000000006044820152fdfea264697066735822122062521c88427f321b7a7f83d9032ab7b9391d203ac6427e5fd9cc60d276a97da564736f6c63430008120033",
  "devdoc": {
    "events": {
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "Paused(address)": {
        "details": "Emitted when the pause is triggered by `account`."
      },
      "Unpaused(address)": {
        "details": "Emitted when the pause is lifted by `account`."
      }
    },
    "kind": "dev",
    "methods": {
      "bridgeCreditAndSwapForTokens(address,uint256,uint256,uint256,address,uint256,uint256)": {
        "details": "Nonce must be non-zero, otherwise wormhole will revert the message"
      },
      "estimateDeliveryFee(uint16,uint256,uint32)": {
        "details": "Note that this function may fail if the value requested is too large. Using deliveryGasLimit 200000 is typically enough",
        "params": {
          "deliveryGasLimit": "gas limit of the callback function on the designated network",
          "receiverValue": "target amount of gas token to receive",
          "toChain": "wormhole chain ID"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)": {
        "details": "core relayer is assumed to be trusted so re-entrancy protection is not required Note: This function should NOT throw; Otherwise it will result in a delivery failure Assumptions to the wormhole relayer:   - The message should deliver typically within 5 minutes   - Unused gas should be refunded to the refundAddress   - The target chain id and target contract address is verified Things to be aware of:   - VAA are not verified, order of message can be changed   - deliveries can potentially performed multiple times (ref: https://book.wormhole.com/technical/evm/relayer.html#delivery-failures)"
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "requestResend(uint16,uint64,uint16,uint256,uint256)": {
        "details": "Redeliver could actually be invoked permisionless on any of the chain that wormhole supports Delivery fee attached to the txn should be done off-chain via `WormholeAdaptor.estimateRedeliveryFee` to reduce gas cost *** This will only be able to succeed if the following is true **         - (For EVM_V1) newGasLimit >= gas limit of the old instruction         - newReceiverValue >= receiver value of the old instruction         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`"
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "stateVariables": {
      "adaptorAddress": {
        "details": "wormhole chainId => adaptor address"
      },
      "deliveredMessage": {
        "details": "hash => is message delivered"
      }
    },
    "title": "WormholeAdaptor",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "approveToken(uint256,address)": {
        "notice": "Permisioneed functions"
      },
      "estimateDeliveryFee(uint16,uint256,uint32)": {
        "notice": "Estimate the amount of message value required to deliver a message with given `deliveryGasLimit` and `receiveValue` A buffer should be added to `deliveryGasLimit` in case the amount of gas required is higher than the expectation"
      },
      "requestResend(uint16,uint64,uint16,uint256,uint256)": {
        "notice": "A convinience function to redeliver"
      },
      "validToken(uint256,address)": {
        "notice": "whether the token is valid"
      }
    },
    "notice": "`WormholeAdaptor` uses the generic relayer of wormhole to send message across different networks",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 717,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 720,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1461,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 589,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "_owner",
        "offset": 0,
        "slot": "51",
        "type": "t_address"
      },
      {
        "astId": 709,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 1020,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "_status",
        "offset": 0,
        "slot": "101",
        "type": "t_uint256"
      },
      {
        "astId": 1089,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 900,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "_paused",
        "offset": 0,
        "slot": "151",
        "type": "t_bool"
      },
      {
        "astId": 1005,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "__gap",
        "offset": 0,
        "slot": "152",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 8878,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "crossChainPool",
        "offset": 0,
        "slot": "201",
        "type": "t_contract(ICrossChainPool)7862"
      },
      {
        "astId": 8880,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "_used",
        "offset": 0,
        "slot": "202",
        "type": "t_uint256"
      },
      {
        "astId": 8887,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "validToken",
        "offset": 0,
        "slot": "203",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 8891,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "__gap",
        "offset": 0,
        "slot": "204",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 15941,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "relayer",
        "offset": 0,
        "slot": "254",
        "type": "t_contract(IWormholeRelayer)8758"
      },
      {
        "astId": 15944,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "wormhole",
        "offset": 0,
        "slot": "255",
        "type": "t_contract(IWormhole)8328"
      },
      {
        "astId": 15949,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "adaptorAddress",
        "offset": 0,
        "slot": "256",
        "type": "t_mapping(t_uint16,t_address)"
      },
      {
        "astId": 15954,
        "contract": "contracts/wombat-core/pool/WormholeAdaptor.sol:WormholeAdaptor",
        "label": "deliveredMessage",
        "offset": 0,
        "slot": "257",
        "type": "t_mapping(t_bytes32,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(ICrossChainPool)7862": {
        "encoding": "inplace",
        "label": "contract ICrossChainPool",
        "numberOfBytes": "20"
      },
      "t_contract(IWormhole)8328": {
        "encoding": "inplace",
        "label": "contract IWormhole",
        "numberOfBytes": "20"
      },
      "t_contract(IWormholeRelayer)8758": {
        "encoding": "inplace",
        "label": "contract IWormholeRelayer",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint16,t_address)": {
        "encoding": "mapping",
        "key": "t_uint16",
        "label": "mapping(uint16 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}