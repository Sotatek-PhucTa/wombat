import { ethers, network } from 'hardhat'
import { BigNumber } from 'ethers'
import chai from 'chai'
import { expect } from 'chai'
import { advanceTimeAndBlock, latest, sqrt } from './helpers'
import { formatEther, parseEther, parseUnits } from '@ethersproject/units'
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers'
import { AddressZero } from '@ethersproject/constants'
import { solidity } from 'ethereum-waffle'
import { near } from './assertions/near'
import { BigNumberish } from '@ethersproject/bignumber'
import { roughlyNear } from './assertions/roughlyNear'

chai.use(solidity)
chai.use(near)
chai.use(roughlyNear)

describe('MasterWombat', function () {
  let owner: SignerWithAddress
  let users: SignerWithAddress[]

  before(async function () {
    ;[owner, ...users] = await ethers.getSigners()
    this.MasterWombat = await ethers.getContractFactory('MasterWombat')
    this.Wom = await ethers.getContractFactory('WombatERC20')
    this.MockERC20 = await ethers.getContractFactory('MockERC20')

    // 80% of emissions generated by MasterWombat at 3,000,000 per month
    this.womPerSec = parseEther('0.9259259259259259')
    this.womPrice = 1 // arbitrary
    this.reward = (sec: number, percent: number) => {
      return (sec * this.womPerSec * percent) / 1000
    }
  })

  beforeEach(async function () {
    this.lastBlock = await ethers.provider.getBlock('latest')
    this.wom = await this.Wom.connect(owner).deploy(parseUnits('1000000', 18)) // 1 mil WOM
    await this.wom.deployed()

    // deploy mock token - 18 d.p
    this.mockERC20 = await this.MockERC20.connect(owner).deploy('mock', 'MOCK', 18, parseEther('100')) // b=2
    await this.mockERC20.deployed()

    // veWom - 18 d.p
    this.veWom = await this.MockERC20.connect(owner).deploy('vewom', 'vewom', 18, parseEther('100')) // b=2
    await this.veWom.deployed()

    // deploy dommy token - 6 d.p.
    this.dummyToken = await this.MockERC20.connect(owner).deploy('Dummy', 'DUMMY', 6, parseUnits('100', 6)) // b=2
    await this.dummyToken.deployed()
  })

  describe('Master Wombat Utils', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)

      // deploy master wombat
      this.mw = await this.MasterWombat.connect(owner).deploy()
      await this.mw.deployed()

      await this.mw.connect(owner).initialize(this.wom.address, this.veWom.address, this.womPerSec, startTime)

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      this.lp = await this.MockERC20.deploy('LPToken', 'LP', 18, parseEther('10000000000'))
      await this.lp.deployed()
      await this.lp.transfer(owner.address, parseEther('1000'))
      await this.lp.transfer(users[1].address, parseEther('1000'))
      await this.lp.transfer(users[2].address, parseEther('1000'))

      this.lp2 = await this.MockERC20.deploy('LPToken2', 'LP2', 6, parseUnits('10000000000', 6))
      await this.lp2.deployed()
      await this.lp2.transfer(owner.address, parseUnits('1000', 6))
      await this.lp2.transfer(users[1].address, parseUnits('1000', 6))
      await this.lp2.transfer(users[2].address, parseUnits('1000', 6))
    })

    it('should pause and unpause', async function () {
      // Pause pool : expect to emit event and for state pause event to change
      const receipt1 = await this.mw.connect(owner).pause()
      expect(await this.mw.paused()).to.equal(true)
      await expect(receipt1).to.emit(this.mw, 'Paused').withArgs(owner.address)

      // Unpause pool : expect emit event and state change
      const receipt2 = await this.mw.connect(owner).unpause()
      expect(await this.mw.paused()).to.equal(false)

      await expect(receipt2).to.emit(this.mw, 'Unpaused').withArgs(owner.address)

      // restricts to owner
      await expect(this.mw.connect(users[0]).pause()).to.be.revertedWith('Ownable: caller is not the owner')
      await expect(this.mw.connect(users[0]).unpause()).to.be.revertedWith('Ownable: caller is not the owner')
    })

    it('withdraw full wom balance on emergencyWomWithdraw', async function () {
      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      // Should revert if called by not owner
      await expect(this.mw.connect(users[1]).emergencyWomWithdraw()).to.be.revertedWith(
        'Ownable: caller is not the owner'
      )

      // Emergency withdraw
      const before = await this.wom.balanceOf(owner.address)
      await this.mw.connect(owner).emergencyWomWithdraw()
      const after = await this.wom.balanceOf(owner.address)

      expect(after.sub(before)).to.be.equal(amountInWei)
    })

    it('only veWom can call updateFactor', async function () {
      await expect(this.mw.updateFactor(users[1].address, parseEther('10'))).to.be.revertedWith(
        'MasterWombat: caller is not VeWom'
      )
      await expect(this.mw.updateFactor(owner.address, parseEther('10'))).to.be.revertedWith(
        'MasterWombat: caller is not VeWom'
      )

      await this.mw.setVeWom(owner.address)
      await expect(this.mw.updateFactor(users[1].address, parseEther('10'))).to.be.ok
    })

    it('should set womPerSec correctly', async function () {
      // add lp to master and deposit
      await this.mw.connect(owner).add('100', this.lp.address, AddressZero)
      await this.lp.connect(owner).approve(this.mw.address, ethers.constants.MaxUint256)
      await this.mw.connect(owner).deposit(0, parseEther('100'))
      expect(await this.mw.womPerSec()).to.equal(this.womPerSec)

      // add lp2. it shouldnt affect wom per sec
      await this.mw.add('900', this.lp2.address, AddressZero)
      expect(await this.mw.womPerSec()).to.equal(this.womPerSec)
      expect(await this.mw.totalAllocPoint()).to.be.equal(1000)
    })

    it('should revert if the same lpToken is added into the pool', async function () {
      await this.mw.add('100', this.lp.address, AddressZero)

      await expect(this.mw.add('100', this.lp.address, AddressZero)).to.be.revertedWith('add: LP already added')
    })

    it('should set correct state variables womPerSec, veWom and emission repartition', async function () {
      // update emission rate
      const receipt = await this.mw.updateEmissionRate(777)
      expect(await this.mw.wom()).to.equal(this.wom.address)
      expect(await this.mw.womPerSec()).to.be.equal(777)

      expect(receipt).to.emit(this.mw, 'UpdateEmissionRate').withArgs(owner.address, 777)

      // update veWom
      expect(await await this.mw.veWom()).to.be.equal(this.veWom.address)
      const receipt1 = await this.mw.setVeWom(this.lp2.address)
      expect(await await this.mw.veWom()).to.be.equal(this.lp2.address)

      expect(receipt1).to.emit(this.mw, 'UpdateVeWom').withArgs(owner.address, this.veWom.address, this.lp2.address)
    })

    it('should check rewarder added and set properly', async function () {
      // Try to add rewarder that is neither zero address or contract address
      await expect(this.mw.add('100', this.lp.address, users[1].address)).to.be.revertedWith(
        'add: rewarder must be contract or zero'
      )

      await this.mw.add('100', this.lp.address, this.dummyToken.address)

      // Try to set rewarder that is neither zero address or contract address
      await expect(this.mw.set('0', '200', users[1].address, true)).to.be.revertedWith(
        'set: rewarder must be contract or zero'
      )

      await this.mw.set('0', '200', this.dummyToken.address, false)
      expect((await this.mw.poolInfo(0)).allocPoint).to.equal('200')
    })

    it('should allow emergency withdraw from MasterWombat', async function () {
      await this.mw.add('100', this.lp.address, AddressZero)

      await this.lp.connect(users[1]).approve(this.mw.address, parseEther('1000'))

      await this.mw.connect(users[1]).deposit(0, parseEther('100'))

      expect(await this.lp.balanceOf(users[1].address)).to.equal(parseEther('900'))

      await this.mw.connect(users[1]).emergencyWithdraw(0)

      expect(await this.lp.balanceOf(users[1].address)).to.equal(parseEther('1000'))
    })

    it('should give out woms only after farming time', async function () {
      // add lp to master wombat
      await this.mw.add('100', this.lp.address, ethers.constants.AddressZero)
      expect(await this.lp.balanceOf(users[1].address)).to.be.equal(parseEther('1000'))

      // approve spending by master and deposit 100 lp
      await this.lp.connect(users[1]).approve(this.mw.address, parseEther('1000'))
      await this.mw.connect(users[1]).deposit(0, parseEther('100'))
      expect(await this.lp.balanceOf(users[1].address)).to.be.equal(parseEther('900'))

      // print reward start time, it is before rewards start
      // console.log(`Master rewards start timestamp : ${await this.mw.startTimestamp()}`)
      // console.log(`Current timestamp 1: ${(await latest()).toNumber()}`)
      expect((await latest()).toNumber() < (await this.mw.startTimestamp()))

      // try to claim
      await this.mw.connect(users[1]).deposit(0, '0')
      expect(await this.wom.balanceOf(users[1].address)).to.equal('0')

      // advance time
      await advanceTimeAndBlock(100)
      // console.log(`Current timestamp 2: ${(await latest()).toNumber()}`)

      // claim again, it should give users[1] wom
      await this.mw.connect(users[1]).deposit(0, '0')
      expect(await this.wom.balanceOf(users[1].address)).to.be.above(parseEther('51'))
      expect(await this.wom.balanceOf(users[1].address)).to.be.below(parseEther('53'))

      // console.log(`Users[1] balance = ${await this.wom.balanceOf(users[1].address)}`)

      await advanceTimeAndBlock(10000)
      // console.log(`Current timestamp 3: ${(await latest()).toNumber()}`)

      await this.mw.connect(users[1]).deposit(0, '0')

      expect(await this.wom.balanceOf(users[1].address)).to.be.near(parseEther('9311.111111111000000000'))
    })

    it('should not distribute woms if no one deposit', async function () {
      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      await this.mw.add('100', this.lp.address, ethers.constants.AddressZero) // t-55
      await this.lp.connect(users[1]).approve(this.mw.address, parseEther('1000')) // t-54
      await advanceTimeAndBlock(100) // t+54

      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)
      await advanceTimeAndBlock(5) // t+59
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)
      await advanceTimeAndBlock(5) // t+64
      await this.mw.connect(users[1]).deposit(0, parseEther('1000')) // t+65
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)
      expect(await this.wom.balanceOf(users[1].address)).to.equal('0')
      expect(await this.lp.balanceOf(users[1].address)).to.equal('0')
      await advanceTimeAndBlock(10) // t+75
      // Revert if users[1] withdraws more than he deposited
      await expect(this.mw.connect(users[1]).withdraw(0, parseEther('1001'))).to.be.revertedWith('withdraw: not good') // t+76
      const [pendingTokens] = await this.mw.connect(users[1]).pendingTokens(0, users[1].address)
      await this.mw.connect(users[1]).withdraw(0, parseEther('1000')) // t+77

      // At this point:
      //   - Total supply is unchanged
      // user should have gather some wom
      expect(await this.wom.totalSupply()).to.be.equal(womTotalSupply)
      // a few secs passed and this is enough for us to have some differences
      expect(pendingTokens).to.be.roughlyNear(parseEther('10.5'))
      expect(await this.wom.balanceOf(users[1].address)).to.be.roughlyNear(parseEther('11.111111111'))
    })
  })

  describe.skip('[USDC Pool] Dialuting pool only', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)

      const emissionsPerSec = parseEther('0.3424657534')

      const MockVeWom = await ethers.getContractFactory('MockVeWom')
      this.mockVeWom = await MockVeWom.connect(owner).deploy()
      this.mockVeWom.deployed()

      // deploy master wombat
      this.mw = await this.MasterWombat.connect(owner).deploy()
      await this.mw.deployed()

      this.mw.connect(owner).initialize(
        this.wom.address,
        this.mockVeWom.address,
        emissionsPerSec,
        1000, // 100 % dialuting
        startTime
      )

      this.mockVeWom.init(this.wom.address, this.mw.address, ethers.constants.AddressZero)

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      // deploy usdc and the other tokens
      this.usdc = await this.MockERC20.deploy('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await this.usdc.deployed()

      this.usdt = await this.MockERC20.deploy('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await this.usdt.deployed()

      this.mim = await this.MockERC20.deploy('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await this.mim.deployed()

      this.dai = await this.MockERC20.deploy('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await this.dai.deployed()

      // credit users with usdc
      await this.usdc.transfer(users[1].address, parseUnits('60000', 6))
      await this.usdc.transfer(users[2].address, parseUnits('90000', 6))
      await this.usdc.transfer(users[3].address, parseUnits('350000', 6))
      await this.usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await this.usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await this.usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockVeWom
      await this.mockVeWom.connect(users[1]).faucet(parseEther('22000'))
      // await this.mockVeWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no vewom.
      await this.mockVeWom.connect(users[3]).faucet(parseEther('3000'))
      await this.mockVeWom.connect(users[4]).faucet(parseEther('128000'))
      await this.mockVeWom.connect(users[5]).faucet(parseEther('5129300'))
      await this.mockVeWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await this.usdc.connect(users[1]).approve(this.mw.address, parseUnits('60000', 6))
      await this.usdc.connect(users[2]).approve(this.mw.address, parseUnits('90000', 6))
      await this.usdc.connect(users[3]).approve(this.mw.address, parseUnits('350000', 6))
      await this.usdc.connect(users[4]).approve(this.mw.address, parseUnits('1500000', 6))
      await this.usdc.connect(users[5]).approve(this.mw.address, parseUnits('18000000', 6))
      await this.usdc.connect(users[6]).approve(this.mw.address, parseUnits('30000000', 6))

      /// other tokens
      await this.usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await this.usdt.connect(users[7]).approve(this.mw.address, parseUnits('50000000', 6))

      await this.dai.transfer(users[8].address, parseEther('40000000'))
      await this.dai.connect(users[8]).approve(this.mw.address, parseUnits('40000000', 18))

      await this.mim.transfer(users[9].address, parseEther('20000000'))
      await this.mim.connect(users[9]).approve(this.mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await this.mw.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mw.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mw.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mw.add('15', this.mim.address, ethers.constants.AddressZero)
      expect(await this.mw.totalAllocPoint()).to.be.equal(100)
      expect(await this.mw.dialutingRepartition()).to.be.equal(1000)
      expect(await this.mw.nonDialutingRepartition()).to.be.equal(0)
    })

    it.skip('should give out wom when withdrawing', async function () {
      // deposit full balance of each user into usdc aggregate
      await this.mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdt
      await this.mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await this.mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // dai
      await this.mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // mim
      await this.mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await this.mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await this.mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await this.mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await this.mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdc users[1]
      await this.mw.connect(users[1]).withdraw(1, parseUnits('60000', 6))
      expect(await this.usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('60000', 6))
      expect(await this.wom.balanceOf(users[1].address)).to.be.near(parseEther('3887.998150404995640000'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc user[2] forgot to stake his wom
      await this.mw.connect(users[2]).withdraw(1, parseUnits('90000', 6))
      expect(await this.usdc.balanceOf(users[2].address)).to.be.equal(parseUnits('90000', 6))
      expect(await this.wom.balanceOf(users[2].address)).to.near(parseEther('5831.997410761184725518'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[3]
      await this.mw.connect(users[3]).withdraw(1, parseUnits('350000', 6))
      expect(await this.usdc.balanceOf(users[3].address)).to.be.equal(parseUnits('350000', 6))
      expect(await this.wom.balanceOf(users[3].address)).to.near(parseEther('22679.990652080049064634'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[4]
      await this.mw.connect(users[4]).withdraw(1, parseUnits('1500000', 6))
      expect(await this.usdc.balanceOf(users[4].address)).to.be.equal(parseUnits('1500000', 6))
      expect(await this.wom.balanceOf(users[4].address)).to.near(parseEther('97199.963050810955471811'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[5]
      await this.mw.connect(users[5]).withdraw(1, parseUnits('18000000', 6))
      expect(await this.usdc.balanceOf(users[5].address)).to.be.equal(parseUnits('18000000', 6))
      expect(await this.wom.balanceOf(users[5].address)).to.near(parseEther('1166399.595137128723161732'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[6]
      await this.mw.connect(users[6]).withdraw(1, parseUnits('30000000', 6))
      expect(await this.usdc.balanceOf(users[6].address)).to.be.equal(parseUnits('30000000', 6))
      expect(await this.wom.balanceOf(users[6].address)).to.near(parseEther('1943999.427968273891936220'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //
    })
  })

  describe.skip('[USDC Pool] Non-dualuting pool only', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)

      const nonDialutingPerSec = parseEther('0.5707762557077626')

      const MockVeWom = await ethers.getContractFactory('MockVeWom')
      this.mockVeWom = await MockVeWom.deploy()
      this.mockVeWom.deployed()

      // deploy master wombat
      this.mw = await this.MasterWombat.deploy()
      await this.mw.deployed()

      this.mw.initialize(
        this.wom.address,
        this.mockVeWom.address,
        nonDialutingPerSec,
        0, // 100% non-dialutng
        startTime
      )

      this.mockVeWom.init(this.wom.address, this.mw.address, ethers.constants.AddressZero)

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      // deploy usdc and the other tokens
      this.usdc = await this.MockERC20.deploy('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await this.usdc.deployed()

      this.usdt = await this.MockERC20.deploy('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await this.usdt.deployed()

      this.mim = await this.MockERC20.deploy('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await this.mim.deployed()

      this.dai = await this.MockERC20.deploy('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await this.dai.deployed()

      // credit users with usdc
      await this.usdc.transfer(users[1].address, parseUnits('60000', 6))
      await this.usdc.transfer(users[2].address, parseUnits('90000', 6))
      await this.usdc.transfer(users[3].address, parseUnits('350000', 6))
      await this.usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await this.usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await this.usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockVeWom
      await this.mockVeWom.connect(users[1]).faucet(parseEther('22000'))
      // await this.mockVeWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no vewom.
      await this.mockVeWom.connect(users[3]).faucet(parseEther('3000'))
      await this.mockVeWom.connect(users[4]).faucet(parseEther('128000'))
      await this.mockVeWom.connect(users[5]).faucet(parseEther('5129300'))
      await this.mockVeWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await this.usdc.connect(users[1]).approve(this.mw.address, parseUnits('60000', 6))
      await this.usdc.connect(users[2]).approve(this.mw.address, parseUnits('90000', 6))
      await this.usdc.connect(users[3]).approve(this.mw.address, parseUnits('350000', 6))
      await this.usdc.connect(users[4]).approve(this.mw.address, parseUnits('1500000', 6))
      await this.usdc.connect(users[5]).approve(this.mw.address, parseUnits('18000000', 6))
      await this.usdc.connect(users[6]).approve(this.mw.address, parseUnits('30000000', 6))

      // add lp-tokens to the wombat master with correct weighing
      await this.mw.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mw.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mw.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mw.add('15', this.mim.address, ethers.constants.AddressZero)
      expect(await this.mw.totalAllocPoint()).to.be.equal(100)
    })

    it.skip('should give out wom when withdrawing', async function () {
      // deposit full balance of each user into usdc aggregate
      await this.mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdt
      await this.mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await this.mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // dai
      await this.mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // mim
      await this.mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await this.mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdc users[1]
      await this.mw.connect(users[1]).withdraw(1, parseUnits('60000', 6))
      expect(await this.usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('60000', 6))
      expect(await this.wom.balanceOf(users[1].address)).to.be.near(parseEther('6051'))

      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc user[2] forgot to stake his wom so no non-dialuting for him!
      await this.mw.connect(users[2]).withdraw(1, parseUnits('90000', 6))
      expect(await this.usdc.balanceOf(users[2].address)).to.be.equal(parseUnits('90000', 6))
      expect(await this.wom.balanceOf(users[2].address)).to.equal(parseEther('0'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[3]
      await this.mw.connect(users[3]).withdraw(1, parseUnits('350000', 6))
      expect(await this.usdc.balanceOf(users[3].address)).to.be.equal(parseUnits('350000', 6))
      expect(await this.wom.balanceOf(users[3].address)).to.near(parseEther('5397.128801919837411024'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[4]
      await this.mw.connect(users[4]).withdraw(1, parseUnits('1500000', 6))
      expect(await this.usdc.balanceOf(users[4].address)).to.be.equal(parseUnits('1500000', 6))
      expect(await this.wom.balanceOf(users[4].address)).to.near(parseEther('72982.504243344401226095'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[5]
      await this.mw.connect(users[5]).withdraw(1, parseUnits('18000000', 6))
      expect(await this.usdc.balanceOf(users[5].address)).to.be.equal(parseUnits('18000000', 6))
      expect(await this.wom.balanceOf(users[5].address)).to.near(parseEther('1600418.134227098652647760'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // withdraw usdc users[6]
      await this.mw.connect(users[6]).withdraw(1, parseUnits('30000000', 6))
      expect(await this.usdc.balanceOf(users[6].address)).to.be.equal(parseUnits('30000000', 6))
      expect(await this.wom.balanceOf(users[6].address)).to.near(parseEther('3715147.590308591070389212'))
      // console.log(`usdc apy : ${(6051/60000) * 100}`) //

      // Withdraw using emergency withdraw from owner
      // Emergency withdraw
      const remainingWomBalance = await this.wom.balanceOf(this.mw.address)

      const before = await this.wom.balanceOf(owner.address)
      await this.mw.connect(owner).emergencyWomWithdraw()
      const after = await this.wom.balanceOf(owner.address)

      expect(after.sub(before)).to.be.equal(remainingWomBalance)
    })
  })

  describe.skip('[All pools] Dialuting pool only', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)

      const dialutingPerSec = parseEther('0.3424657534')

      // deploy master wombat
      this.mw = await this.MasterWombat.deploy()
      await this.mw.deployed()

      this.mw.initialize(
        this.wom.address,
        this.veWom.address,
        dialutingPerSec,
        1000, // 100% dialutng
        startTime
      )

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      this.usdt = await this.MockERC20.deploy('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await this.usdt.deployed()
      await this.usdt.transfer(users[1].address, parseUnits('50000000', 6))
      await this.usdt.transfer(users[2].address, parseUnits('50000000', 6))

      await this.usdt.connect(users[1]).approve(this.mw.address, parseUnits('50000000', 6))
      await this.usdt.connect(users[2]).approve(this.mw.address, parseUnits('50000000', 6))

      this.usdc = await this.MockERC20.deploy('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await this.usdc.deployed()
      await this.usdc.transfer(users[1].address, parseUnits('50000000', 6))
      await this.usdc.transfer(users[2].address, parseUnits('50000000', 6))

      await this.usdc.connect(users[1]).approve(this.mw.address, parseUnits('50000000', 6))
      await this.usdc.connect(users[2]).approve(this.mw.address, parseUnits('50000000', 6))

      this.dai = await this.MockERC20.deploy('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await this.dai.deployed()
      await this.dai.transfer(users[1].address, parseEther('40000000'))
      await this.dai.transfer(users[2].address, parseEther('40000000'))

      await this.dai.connect(users[1]).approve(this.mw.address, parseUnits('40000000', 18))
      await this.dai.connect(users[2]).approve(this.mw.address, parseUnits('40000000', 18))

      this.mim = await this.MockERC20.deploy('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await this.mim.deployed()
      await this.mim.transfer(users[1].address, parseEther('20000000'))
      await this.mim.transfer(users[2].address, parseEther('20000000'))

      await this.mim.connect(users[1]).approve(this.mw.address, parseUnits('20000000', 18))
      await this.mim.connect(users[2]).approve(this.mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master
      await this.mw.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mw.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mw.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mw.add('15', this.mim.address, ethers.constants.AddressZero)
      expect(await this.mw.totalAllocPoint()).to.be.equal(100)

      // deposit
      await this.mw.connect(users[1]).deposit(0, parseUnits('50000000', 6)) // usdt
      await this.mw.connect(users[1]).deposit(1, parseUnits('50000000', 6)) // usdc
      await this.mw.connect(users[1]).deposit(2, parseEther('40000000')) // dai
      await this.mw.connect(users[1]).deposit(3, parseEther('20000000')) // mim
    })

    it.skip('should withdraw and claim wom', async function () {
      const randomAddress = '0xA73274A8186D9194c9816baA778392CB8a935926'

      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdt
      await this.mw.connect(users[1]).withdraw(0, parseUnits('50000000', 6))
      expect(await this.usdt.balanceOf(users[1].address)).to.be.equal(parseUnits('50000000', 6))
      let womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(parseEther('3239997.02031466542000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdt apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw usdc
      await this.mw.connect(users[1]).withdraw(1, parseUnits('50000000', 6))
      expect(await this.usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('50000000', 6))
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('3239997.225794117460000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdc apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw dai
      await this.mw.connect(users[1]).withdraw(2, parseEther('40000000'))
      expect(await this.dai.balanceOf(users[1].address)).to.be.equal(parseUnits('40000000', 18))
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('2699997.859360000000000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`dai apy : ${(2699997/40000000) * 100}`) //6.7499925

      // withdraw mim
      await this.mw.connect(users[1]).withdraw(3, parseEther('20000000'))
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(await this.mim.balanceOf(users[1].address)).to.be.equal(parseUnits('20000000', 18))
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1619998.818360000000000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`mim apy : ${((1619998)/20000000) * 100}`) //8.09999
    })

    it.skip('should multiclaim from certain pools only', async function () {
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year
      const expectedYearlyRewardsPool12 = parseEther('3239997.02031466542000000').add(
        parseEther('3239997.225794117460000000')
      )

      const expectedYearlyRewardsPool34 = parseEther('2699997.859360000000000000').add(
        parseEther('1619998.818360000000000000')
      )

      // Using a callStatic in order to get the returned value of a non view function
      const [womTotal, womAmounts, additionalRewards] = await this.mw.connect(users[1]).callStatic.multiClaim([0, 1])
      expect(womTotal).to.near(expectedYearlyRewardsPool12)
      expect(womAmounts.length).to.eq(2)
      expect(additionalRewards.length).to.eq(2)

      // multiclaim pools 0 and 1
      await this.mw.connect(users[1]).multiClaim([0, 1])
      let womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewardsPool12)
      // console.log(womBalance)

      // multiclaim again, this time the other pools 3, 4
      await this.mw.connect(users[1]).multiClaim([2, 3])
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewardsPool34.add(expectedYearlyRewardsPool12))
    })

    it.skip('should multiclaim from one pool only', async function () {
      const pids = [3]
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year
      const expectedYearlyRewards = parseEther('1619998.818360000000000000')

      const [pending] = await this.mw.pendingTokens(3, users[1].address)

      // multiclaim
      await this.mw.connect(users[1]).multiClaim(pids)
      const womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewards)
      expect(womBalance).to.near(pending)
      // console.log(womBalance)
    })

    it.skip('should multiclaim from all pools', async function () {
      const pids = [0, 1, 2, 3]
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      const expectedYearlyRewards = parseEther('3239997.02031466542000000')
        .add(parseEther('3239997.225794117460000000'))
        .add(parseEther('2699997.859360000000000000'))
        .add(parseEther('1619998.818360000000000000'))

      // multiclaim
      await this.mw.connect(users[1]).multiClaim(pids)
      let womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewards)
      // console.log(womBalance)

      // ROUND 2
      // let another year pass
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // multiclaim again
      await this.mw.connect(users[1]).multiClaim(pids)
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewards.mul(2))
      // console.log(womBalance)
    })

    it.skip('should claim with the deposit function', async function () {
      const randomAddress = '0xA73274A8186D9194c9816baA778392CB8a935926'

      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdt
      await this.mw.connect(users[1]).deposit(0, 0)
      let womBalance = await this.wom.balanceOf(users[1].address)
      expect(womBalance).to.near(parseEther('3239997.020314665420000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdt apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw usdc
      await this.mw.connect(users[1]).deposit(1, 0)
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('3239997.225794117460000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdc apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw dai
      await this.mw.connect(users[1]).deposit(2, 0)
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('2699997.859360000000000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`dai apy : ${(2699997/40000000) * 100}`) //6.7499925

      // withdraw mim
      await this.mw.connect(users[1]).deposit(3, 0)
      womBalance = await this.wom.balanceOf(users[1].address)
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1619998.818360000000000000'))
      await this.wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`mim apy : ${((1619998)/20000000) * 100}`) //8.09999
    })
  })

  describe.skip('[All pools] Dialuting + non-dialuting pool', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)

      const emissionsPerSec = parseEther('0.91324200913242')

      const MockVeWom = await ethers.getContractFactory('MockVeWom')
      this.mockVeWom = await MockVeWom.deploy()
      this.mockVeWom.deployed()

      // deploy master wombat
      this.mw = await this.MasterWombat.deploy()
      await this.mw.deployed()

      this.mw.initialize(
        this.wom.address,
        this.mockVeWom.address,
        emissionsPerSec,
        375, // 37.5% dialuting => corresponds to 30% / 50% (with 20 % allocated externally)
        startTime
      )

      this.mockVeWom.init(this.wom.address, this.mw.address, ethers.constants.AddressZero)

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      // deploy usdc and the other tokens
      this.usdc = await this.MockERC20.deploy('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await this.usdc.deployed()

      this.usdt = await this.MockERC20.deploy('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await this.usdt.deployed()

      this.mim = await this.MockERC20.deploy('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await this.mim.deployed()

      this.dai = await this.MockERC20.deploy('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await this.dai.deployed()

      // credit users with usdc
      await this.usdc.transfer(users[1].address, parseUnits('60000', 6))
      await this.usdc.transfer(users[2].address, parseUnits('90000', 6))
      await this.usdc.transfer(users[3].address, parseUnits('350000', 6))
      await this.usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await this.usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await this.usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockVeWom
      await this.mockVeWom.connect(users[1]).faucet(parseEther('22000'))
      // await this.mockVeWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no vewom.
      await this.mockVeWom.connect(users[3]).faucet(parseEther('3000'))
      await this.mockVeWom.connect(users[4]).faucet(parseEther('128000'))
      await this.mockVeWom.connect(users[5]).faucet(parseEther('5129300'))
      await this.mockVeWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await this.usdc.connect(users[1]).approve(this.mw.address, parseUnits('60000', 6))
      await this.usdc.connect(users[2]).approve(this.mw.address, parseUnits('90000', 6))
      await this.usdc.connect(users[3]).approve(this.mw.address, parseUnits('350000', 6))
      await this.usdc.connect(users[4]).approve(this.mw.address, parseUnits('1500000', 6))
      await this.usdc.connect(users[5]).approve(this.mw.address, parseUnits('18000000', 6))
      await this.usdc.connect(users[6]).approve(this.mw.address, parseUnits('30000000', 6))

      /// other tokens
      await this.usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await this.usdt.connect(users[7]).approve(this.mw.address, parseUnits('50000000', 6))

      await this.dai.transfer(users[8].address, parseEther('40000000'))
      await this.dai.connect(users[8]).approve(this.mw.address, parseUnits('40000000', 18))

      await this.mim.transfer(users[9].address, parseEther('20000000'))
      await this.mim.connect(users[9]).approve(this.mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await this.mw.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mw.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mw.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mw.add('15', this.mim.address, ethers.constants.AddressZero)
      expect(await this.mw.totalAllocPoint()).to.be.equal(100)
      expect(await this.mw.dialutingRepartition()).to.be.equal(375)
      expect(await this.mw.nonDialutingRepartition()).to.be.equal(625)

      /// deposits
      // deposit full balance of each user into usdc pool
      await this.mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await this.mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await this.mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await this.mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await this.mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await this.mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await this.mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await this.mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await this.mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
    })

    it.skip('should withdraw and claim wom', async function () {
      const randomAddress = '0x0B306BF915C4d645ff596e518fAf3F9669b97016'
      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdc users[1]
      let [pendingTokens] = await this.mw.connect(users[1]).pendingTokens(1, users[1].address)
      await this.mw.connect(users[1]).withdraw(1, parseUnits('60000', 6))
      expect(await this.usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('60000', 6))
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('9939.388872069638364101'))
      expect(await this.wom.balanceOf(users[1].address)).to.near(pendingTokens)
      // console.log(`usdc apy : ${(9939 / 60000) * 100}`) //

      // withdraw usdc user[2] forgot to stake his wom
      ;[pendingTokens] = await this.mw.connect(users[2]).pendingTokens(1, users[2].address)
      await this.mw.connect(users[2]).withdraw(1, parseUnits('90000', 6))
      expect(await this.usdc.balanceOf(users[2].address)).to.be.equal(parseUnits('90000', 6))
      expect(await this.wom.balanceOf(users[2].address)).to.near(parseEther('5831.997411181087955923'))
      expect(await this.wom.balanceOf(users[2].address)).to.near(pendingTokens)
      // console.log(`usdc apy : ${(5831 / 90000) * 100}`) //

      // withdraw usdc users[3]
      ;[pendingTokens] = await this.mw.connect(users[3]).pendingTokens(1, users[3].address)
      await this.mw.connect(users[3]).withdraw(1, parseUnits('350000', 6))
      expect(await this.usdc.balanceOf(users[3].address)).to.be.equal(parseUnits('350000', 6))
      expect(await this.wom.balanceOf(users[3].address)).to.near(parseEther('28077.120995910401561749'))
      expect(await this.wom.balanceOf(users[3].address)).to.near(pendingTokens)
      // console.log(`usdc apy : ${(28077 / 350000) * 100}`) //

      // withdraw usdc users[4]
      ;[pendingTokens] = await this.mw.connect(users[4]).pendingTokens(1, users[4].address)
      await this.mw.connect(users[4]).withdraw(1, parseUnits('1500000', 6))
      expect(await this.usdc.balanceOf(users[4].address)).to.be.equal(parseUnits('1500000', 6))
      expect(await this.wom.balanceOf(users[4].address)).to.near(parseEther('170182.488129507850388275'))
      expect(await this.wom.balanceOf(users[4].address)).to.near(pendingTokens)
      // console.log(`usdc apy : ${(170182 / 1500000) * 100}`) //

      // withdraw usdc users[5]
      ;[pendingTokens] = await this.mw.connect(users[5]).pendingTokens(1, users[5].address)
      await this.mw.connect(users[5]).withdraw(1, parseUnits('18000000', 6))
      expect(await this.usdc.balanceOf(users[5].address)).to.be.equal(parseUnits('18000000', 6))
      expect(await this.wom.balanceOf(users[5].address)).to.near(parseEther('2766818.186188832228206931'))
      expect(await this.wom.balanceOf(users[5].address)).to.near(pendingTokens)
      // console.log(`usdc apy : ${(2766818 / 18000000) * 100}`) //

      // withdraw usdc users[6]
      ;[pendingTokens] = await this.mw.connect(users[6]).pendingTokens(1, users[6].address)
      await this.mw.connect(users[6]).withdraw(1, parseUnits('30000000', 6))
      expect(await this.usdc.balanceOf(users[6].address)).to.be.equal(parseUnits('30000000', 6))
      expect(await this.wom.balanceOf(users[6].address)).to.near(parseEther('5659148.078676470434729143'))
      expect(await this.wom.balanceOf(users[6].address)).to.near(pendingTokens)
      // console.log(`usdc apy : ${(5659148 / 30000000) * 100}`) //

      /////

      // withdraw usdt
      ;[pendingTokens] = await this.mw.connect(users[7]).pendingTokens(0, users[7].address)
      await this.mw.connect(users[7]).withdraw(0, parseUnits('50000000', 6))
      expect(await this.usdt.balanceOf(users[7].address)).to.be.equal(parseUnits('50000000', 6))
      let womBalance = await this.wom.balanceOf(users[7].address)
      expect(womBalance).to.be.near(parseEther('3239999.075342465429424750'))
      expect(await this.wom.balanceOf(users[7].address)).to.near(pendingTokens)
      await this.wom.connect(users[7]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[7].address)).to.be.equal(0)
      // console.log(`usdt apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw dai
      ;[pendingTokens] = await this.mw.connect(users[8]).pendingTokens(2, users[8].address)
      await this.mw.connect(users[8]).withdraw(2, parseEther('40000000'))
      expect(await this.dai.balanceOf(users[8].address)).to.be.equal(parseUnits('40000000', 18))
      womBalance = await this.wom.balanceOf(users[8].address)
      expect(womBalance).to.be.near(parseEther('2699999.400680000000000000'))
      expect(await this.wom.balanceOf(users[8].address)).to.near(pendingTokens)
      await this.wom.connect(users[8]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[8].address)).to.be.equal(0)
      // console.log(`dai apy : ${(2699997/40000000) * 100}`) //6.7499925

      // withdraw mim
      ;[pendingTokens] = await this.mw.connect(users[9]).pendingTokens(3, users[9].address)
      await this.mw.connect(users[9]).withdraw(3, parseEther('20000000'))
      womBalance = await this.wom.balanceOf(users[9].address)
      expect(await this.mim.balanceOf(users[9].address)).to.be.equal(parseUnits('20000000', 18))
      expect(womBalance).to.be.near(parseEther('1619999.743140000000000000'))
      expect(await this.wom.balanceOf(users[9].address)).to.near(pendingTokens)
      await this.wom.connect(users[9]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[9].address)).to.be.equal(0)
      // console.log(`mim apy : ${((1619998)/20000000) * 100}`) //8.09999
    })

    it.skip('should claim with the deposit function', async function () {
      const randomAddress = '0x0B306BF915C4d645ff596e518fAf3F9669b97016'
      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdc users[1]
      await this.mw.connect(users[1]).deposit(1, 0)
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('9939.388872069638364101'))
      // console.log(`usdc apy : ${(9939 / 60000) * 100}`) //

      // withdraw usdc user[2] forgot to stake his wom
      await this.mw.connect(users[2]).deposit(1, 0)
      expect(await this.wom.balanceOf(users[2].address)).to.near(parseEther('5831.997410958903526389'))
      // console.log(`usdc apy : ${(5831 / 90000) * 100}`) //

      // withdraw usdc users[3]
      await this.mw.connect(users[3]).deposit(1, 0)
      expect(await this.wom.balanceOf(users[3].address)).to.near(parseEther('28077.120992498321283487'))
      // console.log(`usdc apy : ${(28077 / 350000) * 100}`) //

      // withdraw usdc users[4]
      await this.mw.connect(users[4]).deposit(1, 0)
      expect(await this.wom.balanceOf(users[4].address)).to.near(parseEther('170182.488075287569718778'))
      // console.log(`usdc apy : ${(170182 / 1500000) * 100}`) //

      // withdraw usdc users[5]
      await this.mw.connect(users[5]).deposit(1, 0)
      expect(await this.wom.balanceOf(users[5].address)).to.near(parseEther('2766818.183090634366063747'))
      // console.log(`usdc apy : ${(2766818 / 18000000) * 100}`) //

      // withdraw usdc users[6]
      await this.mw.connect(users[6]).deposit(1, 0)
      expect(await this.wom.balanceOf(users[6].address)).to.near(parseEther('5659147.978317789854464367'))
      // console.log(`usdc apy : ${(5659148 / 30000000) * 100}`) //

      /////

      // withdraw usdt
      await this.mw.connect(users[7]).deposit(0, 0)
      let womBalance = await this.wom.balanceOf(users[7].address)
      expect(womBalance).to.near(parseEther('3239999.075342465429424750'))
      await this.wom.connect(users[7]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[7].address)).to.be.equal(0)
      // console.log(`usdt apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw dai
      await this.mw.connect(users[8]).deposit(2, 0)
      womBalance = await this.wom.balanceOf(users[8].address)
      expect(womBalance).to.near(parseEther('2699999.400680000000000000'))
      await this.wom.connect(users[8]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[8].address)).to.be.equal(0)
      // console.log(`dai apy : ${(2699997/40000000) * 100}`) //6.7499925

      // withdraw mim
      await this.mw.connect(users[9]).withdraw(3, 0)
      womBalance = await this.wom.balanceOf(users[9].address)
      expect(womBalance).to.near(parseEther('1619999.743140000000000000'))
      await this.wom.connect(users[9]).transfer(randomAddress, womBalance) // burn the wom
      expect(await this.wom.balanceOf(users[9].address)).to.be.equal(0)
      // console.log(`mim apy : ${((1619998)/20000000) * 100}`) //8.09999
    })
  })

  describe.skip('[All pools] vewom integration test', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)

      const emissionsPerSec = parseEther('0.91324200913242')

      const MockVeWom = await ethers.getContractFactory('MockVeWom')
      this.mockVeWom = await MockVeWom.deploy()
      this.mockVeWom.deployed()

      // deploy master wombat
      this.mw = await this.MasterWombat.deploy()
      await this.mw.deployed()

      await this.mw.initialize(this.wom.address, this.mockVeWom.address, emissionsPerSec, startTime)

      await this.mockVeWom.init(this.wom.address, this.mw.address, ethers.constants.AddressZero)

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      // deploy usdc and the other tokens
      this.usdc = await this.MockERC20.deploy('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await this.usdc.deployed()

      this.usdt = await this.MockERC20.deploy('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await this.usdt.deployed()

      this.mim = await this.MockERC20.deploy('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await this.mim.deployed()

      this.dai = await this.MockERC20.deploy('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await this.dai.deployed()

      // credit users with usdc
      await this.usdc.transfer(users[1].address, parseUnits('60000', 6))
      await this.usdc.transfer(users[2].address, parseUnits('90000', 6))
      await this.usdc.transfer(users[3].address, parseUnits('350000', 6))
      await this.usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await this.usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await this.usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockVeWom
      await this.mockVeWom.connect(users[1]).faucet(parseEther('22000'))
      // await this.mockVeWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no vewom.
      await this.mockVeWom.connect(users[3]).faucet(parseEther('3000'))
      await this.mockVeWom.connect(users[4]).faucet(parseEther('128000'))
      await this.mockVeWom.connect(users[5]).faucet(parseEther('5129300'))
      await this.mockVeWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await this.usdc.connect(users[1]).approve(this.mw.address, parseUnits('60000', 6))
      await this.usdc.connect(users[2]).approve(this.mw.address, parseUnits('90000', 6))
      await this.usdc.connect(users[3]).approve(this.mw.address, parseUnits('350000', 6))
      await this.usdc.connect(users[4]).approve(this.mw.address, parseUnits('1500000', 6))
      await this.usdc.connect(users[5]).approve(this.mw.address, parseUnits('18000000', 6))
      await this.usdc.connect(users[6]).approve(this.mw.address, parseUnits('30000000', 6))

      /// other tokens
      await this.usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await this.usdt.connect(users[7]).approve(this.mw.address, parseUnits('50000000', 6))

      await this.dai.transfer(users[8].address, parseEther('40000000'))
      await this.dai.connect(users[8]).approve(this.mw.address, parseUnits('40000000', 18))

      await this.mim.transfer(users[9].address, parseEther('20000000'))
      await this.mim.connect(users[9]).approve(this.mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await this.mw.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mw.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mw.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mw.add('15', this.mim.address, ethers.constants.AddressZero)
      expect(await this.mw.totalAllocPoint()).to.be.equal(100)

      // NEW USER with 10k vewom and 10k everything
      await this.mockVeWom.connect(users[10]).faucet(parseEther('10000'))

      await this.usdt.transfer(users[10].address, parseUnits('10000', 6))
      await this.usdc.transfer(users[10].address, parseUnits('10000', 6))
      await this.dai.transfer(users[10].address, parseUnits('10000', 18))
      await this.mim.transfer(users[10].address, parseUnits('10000', 18))

      await this.usdt.connect(users[10]).approve(this.mw.address, parseUnits('10000', 6))
      await this.usdc.connect(users[10]).approve(this.mw.address, parseUnits('10000', 6))
      await this.dai.connect(users[10]).approve(this.mw.address, parseUnits('10000', 18))
      await this.mim.connect(users[10]).approve(this.mw.address, parseUnits('10000', 18))

      /// deposits
      // deposit full balance of each user into usdc pool
      await this.mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await this.mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await this.mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await this.mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await this.mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await this.mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await this.mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await this.mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await this.mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim

      // NEW USER deposits
      await this.mw.connect(users[10]).deposit(0, parseUnits('10000', 6)) // usdc
      await this.mw.connect(users[10]).deposit(1, parseUnits('10000', 6)) // usdt
      await this.mw.connect(users[10]).deposit(2, parseUnits('10000', 18)) // dai
      await this.mw.connect(users[10]).deposit(3, parseUnits('10000', 18)) // mim
    })

    it.skip('should set & update factor and sumOfFactors correctly', async function () {
      /// usdt 0 / usdc 1 / dai 2 / mim 3
      /// === First part === ///
      /// (1) first check each pool sumOfFactors and users[10] factor per pool

      const user10Factors = new Map<number, BigNumberish>([
        [0, sqrt(parseUnits('10000', 6).mul(parseEther('10000')))],
        [1, sqrt(parseUnits('10000', 6).mul(parseEther('10000')))],
        [2, sqrt(parseUnits('10000', 18).mul(parseEther('10000')))],
        [3, sqrt(parseUnits('10000', 18).mul(parseEther('10000')))],
      ])

      // USDT
      let usdtPoolInfo = await this.mw.poolInfo(0)
      let userInfoUsdt = await this.mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(user10Factors.get(0))
      // users[7] has no vewom so sumOfFactors is just users[10] factor
      expect(usdtPoolInfo.sumOfFactors).to.be.equal(user10Factors.get(0))

      // USDC
      let usdcPoolInfo = await this.mw.poolInfo(1)
      let userInfoUsdc = await this.mw.userInfo(1, users[10].address)
      let usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
        .add(sqrt(parseUnits('10000', 6).mul(parseEther('10000'))))
      expect(userInfoUsdc.factor).to.be.equal(user10Factors.get(1))
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      let daiPoolInfo = await this.mw.poolInfo(2)
      let userInfoDai = await this.mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(user10Factors.get(2))
      expect(daiPoolInfo.sumOfFactors).to.be.equal(user10Factors.get(2))

      // MIM
      let mimPoolInfo = await this.mw.poolInfo(3)
      let userInfoMim = await this.mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(user10Factors.get(3))
      expect(mimPoolInfo.sumOfFactors).to.be.equal(user10Factors.get(3))

      /// === Second part === ///
      /// (2) Mint vewom and see if factor and sumOfFactors updates correctly for each pool
      // mint for users[7]
      await this.mockVeWom.connect(users[7]).faucet(parseEther('10000'))
      // mint for users[10]
      await this.mockVeWom.connect(users[10]).faucet(parseEther('10000'))

      // USDT
      usdtPoolInfo = await this.mw.poolInfo(0)
      userInfoUsdt = await this.mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(sqrt(parseUnits('10000', 6).mul(parseEther('20000'))))
      // users[7] now has vewom so sumOfFactors is updated
      expect(usdtPoolInfo.sumOfFactors).to.be.equal(
        sqrt(parseUnits('50000000', 6).mul(parseEther('10000'))).add(
          sqrt(parseUnits('10000', 6).mul(parseEther('20000')))
        )
      )

      // USDC
      usdcPoolInfo = await this.mw.poolInfo(1)
      userInfoUsdc = await this.mw.userInfo(1, users[10].address)
      usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
        .add(sqrt(parseUnits('10000', 6).mul(parseEther('20000'))))
      expect(userInfoUsdc.factor).to.be.equal(sqrt(parseUnits('10000', 6).mul(parseEther('20000'))))
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      daiPoolInfo = await this.mw.poolInfo(2)
      userInfoDai = await this.mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))
      expect(daiPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))

      // MIM
      mimPoolInfo = await this.mw.poolInfo(3)
      userInfoMim = await this.mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))
      expect(mimPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))

      /// === Third part === ///
      /// (3) then burn vewom and see if factor and sumOfFactors updates correctly for each pool
      await this.mockVeWom.burn(users[10].address, parseEther('20000'))

      // USDT
      usdtPoolInfo = await this.mw.poolInfo(0)
      userInfoUsdt = await this.mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(0)
      expect((await this.mw.userInfo(0, users[7].address)).factor).to.be.equal(
        sqrt(parseUnits('50000000', 6).mul(parseEther('10000')))
      )

      expect(usdtPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('50000000', 6).mul(parseEther('10000'))))

      // USDC
      usdcPoolInfo = await this.mw.poolInfo(1)
      userInfoUsdc = await this.mw.userInfo(1, users[10].address)
      usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
      expect(userInfoUsdc.factor).to.be.equal(0)
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      daiPoolInfo = await this.mw.poolInfo(2)
      userInfoDai = await this.mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(0)
      expect(daiPoolInfo.sumOfFactors).to.be.equal(0)

      // MIM
      mimPoolInfo = await this.mw.poolInfo(3)
      userInfoMim = await this.mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(0)
      expect(mimPoolInfo.sumOfFactors).to.be.equal(0)
    })
  })

  describe('[All pools] LP token Migration', function () {
    beforeEach(async function () {
      // We make start time 60 seconds past the last block
      const startTime = (await latest()).add(60)
      const emissionsPerSec = parseEther('0.91324200913242')
      const MockVeWom = await ethers.getContractFactory('MockVeWom')
      this.mockVeWom = await MockVeWom.deploy()
      this.mockVeWom.deployed()

      // deploy master wombat
      this.mw = await this.MasterWombat.deploy()
      await this.mw.deployed()

      await this.mw.initialize(this.wom.address, this.mockVeWom.address, emissionsPerSec, startTime)

      this.mockVeWom.init(this.wom.address, this.mw.address, ethers.constants.AddressZero)

      const womTotalSupply = await this.wom.totalSupply()
      const amount = parseInt(formatEther(womTotalSupply)) * 0.4
      const amountInWei = parseEther(amount.toString())

      // transfer 40% of wom supply to master wombat contract
      await this.wom.connect(owner).transfer(this.mw.address, amountInWei)
      expect(await this.wom.balanceOf(this.mw.address)).to.be.equal(amountInWei)

      // deploy usdc and the other tokens
      this.usdc = await this.MockERC20.deploy('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await this.usdc.deployed()

      this.usdt = await this.MockERC20.deploy('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await this.usdt.deployed()

      this.mim = await this.MockERC20.deploy('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await this.mim.deployed()

      this.dai = await this.MockERC20.deploy('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await this.dai.deployed()

      // credit users with usdc
      await this.usdc.transfer(users[1].address, parseUnits('60000', 6))
      await this.usdc.transfer(users[2].address, parseUnits('90000', 6))
      await this.usdc.transfer(users[3].address, parseUnits('350000', 6))
      await this.usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await this.usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await this.usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockVeWom
      await this.mockVeWom.connect(users[1]).faucet(parseEther('22000'))
      // await this.mockVeWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no vewom.
      await this.mockVeWom.connect(users[3]).faucet(parseEther('3000'))
      await this.mockVeWom.connect(users[4]).faucet(parseEther('128000'))
      await this.mockVeWom.connect(users[5]).faucet(parseEther('5129300'))
      await this.mockVeWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await this.usdc.connect(users[1]).approve(this.mw.address, parseUnits('60000', 6))
      await this.usdc.connect(users[2]).approve(this.mw.address, parseUnits('90000', 6))
      await this.usdc.connect(users[3]).approve(this.mw.address, parseUnits('350000', 6))
      await this.usdc.connect(users[4]).approve(this.mw.address, parseUnits('1500000', 6))
      await this.usdc.connect(users[5]).approve(this.mw.address, parseUnits('18000000', 6))
      await this.usdc.connect(users[6]).approve(this.mw.address, parseUnits('30000000', 6))

      /// other tokens
      await this.usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await this.usdt.connect(users[7]).approve(this.mw.address, parseUnits('50000000', 6))

      await this.dai.transfer(users[8].address, parseEther('40000000'))
      await this.dai.connect(users[8]).approve(this.mw.address, parseUnits('40000000', 18))

      await this.mim.transfer(users[9].address, parseEther('20000000'))
      await this.mim.connect(users[9]).approve(this.mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await this.mw.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mw.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mw.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mw.add('15', this.mim.address, ethers.constants.AddressZero)
      expect(await this.mw.totalAllocPoint()).to.be.equal(100)

      /// deposits
      // deposit full balance of each user into usdc pool
      await this.mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await this.mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await this.mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await this.mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await this.mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await this.mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await this.mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await this.mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await this.mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
    })

    it('should revert if newMasterWombat not set', async function () {
      await expect(this.mw.connect(users[1]).migrate([1, 0])).to.be.revertedWith('to where?')
    })

    it('user should be able to migrate once only ', async function () {
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // deploy V2 master wombat
      const startTime = (await latest()).add(60)
      const emissionsPerSec = parseEther('0.3424657534')

      this.mwV2 = await this.MasterWombat.deploy()
      await this.mw.deployed()

      await this.mwV2.initialize(this.wom.address, this.mockVeWom.address, emissionsPerSec, startTime)
      await this.mwV2.connect(owner).add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mwV2.connect(owner).add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mwV2.connect(owner).add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mwV2.connect(owner).add('15', this.mim.address, ethers.constants.AddressZero)

      await this.mw.connect(owner).setNewMasterWombat(this.mwV2.address)

      // migrate usdc users[1]
      const [pendingTokens] = await this.mw.connect(users[1]).pendingTokens(1, users[1].address)
      const [amountPool1] = await this.mw.userInfo(1, users[1].address)
      const [amountPool0] = await this.mw.userInfo(0, users[1].address)
      await this.mw.connect(users[1]).migrate([1, 0])
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1896.078577536010467861'))
      expect(await this.wom.balanceOf(users[1].address)).to.near(pendingTokens)
      expect((await this.mwV2.userInfo(1, users[1].address)).amount).to.equal(amountPool1)
      expect((await this.mwV2.userInfo(0, users[1].address)).amount).to.equal(amountPool0)

      // nothing to migrate, nothing should be claimed and migrated
      await this.mw.connect(users[1]).migrate([1, 0])
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1896.078577536010467861'))
      expect(await this.wom.balanceOf(users[1].address)).to.near(pendingTokens)
      expect((await this.mwV2.userInfo(1, users[1].address)).amount).to.equal(amountPool1)
      expect((await this.mwV2.userInfo(0, users[1].address)).amount).to.equal(amountPool0)
    })

    it('should claim wom before migrate()', async function () {
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // deploy V2 master wombat
      const startTime = (await latest()).add(60)
      const emissionsPerSec = parseEther('0.3424657534')

      this.mwV2 = await this.MasterWombat.deploy()
      await this.mw.deployed()

      await this.mwV2.initialize(this.wom.address, this.mockVeWom.address, emissionsPerSec, startTime)
      await this.mwV2.add('30', this.usdt.address, ethers.constants.AddressZero)
      await this.mwV2.add('30', this.usdc.address, ethers.constants.AddressZero)
      await this.mwV2.add('25', this.dai.address, ethers.constants.AddressZero)
      await this.mwV2.add('15', this.mim.address, ethers.constants.AddressZero)

      await this.mw.connect(owner).setNewMasterWombat(this.mwV2.address)

      // migrate usdc users[1]
      let [pendingTokens] = await this.mw.connect(users[1]).pendingTokens(1, users[1].address)
      let [amountPool1] = await this.mw.userInfo(1, users[1].address)
      let [amountPool0] = await this.mw.userInfo(0, users[1].address)
      await this.mw.connect(users[1]).migrate([1, 0])
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1896.078577536010467861'))
      expect(await this.wom.balanceOf(users[1].address)).to.near(pendingTokens)
      expect((await this.mwV2.userInfo(1, users[1].address)).amount).to.equal(amountPool1)
      expect((await this.mwV2.userInfo(0, users[1].address)).amount).to.equal(amountPool0)

      // migrate usdc users[2]
      ;[pendingTokens] = await this.mw.connect(users[2]).pendingTokens(1, users[2].address)
      ;[amountPool1] = await this.mw.userInfo(1, users[2].address)
      ;[amountPool0] = await this.mw.userInfo(0, users[2].address)
      await this.mw.connect(users[2]).migrate([1, 0])
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1896.078577536010467861'))
      expect(await this.wom.balanceOf(users[2].address)).to.near(pendingTokens)
      expect((await this.mwV2.userInfo(1, users[2].address)).amount).to.equal(amountPool1)
      expect((await this.mwV2.userInfo(0, users[2].address)).amount).to.equal(amountPool0)
    })

    it('should claim wom in both old and new MasterWombat pool during migrate()', async function () {
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // initialize mpV2
      {
        const startTime = (await latest()).add(60 * 60 * 24)
        const emissionsPerSec = parseEther('0.91324200913242')

        // deploy master wombat
        this.mwV2 = await this.MasterWombat.deploy()
        await this.mwV2.deployed()

        await this.mwV2.initialize(this.wom.address, this.mockVeWom.address, emissionsPerSec, startTime)

        const womTotalSupply = await this.wom.totalSupply()
        const amount = parseInt(formatEther(womTotalSupply)) * 0.4
        const amountInWei = parseEther(amount.toString())

        // transfer 40% of wom supply to master wombat contract
        await this.wom.connect(owner).transfer(this.mwV2.address, amountInWei)
        expect(await this.wom.balanceOf(this.mwV2.address)).to.be.equal(amountInWei)

        // credit users with usdc
        await this.usdc.transfer(users[1].address, parseUnits('60000', 6))
        await this.usdc.transfer(users[2].address, parseUnits('90000', 6))
        await this.usdc.transfer(users[3].address, parseUnits('350000', 6))
        await this.usdc.transfer(users[4].address, parseUnits('1500000', 6))
        await this.usdc.transfer(users[5].address, parseUnits('18000000', 6))
        await this.usdc.transfer(users[6].address, parseUnits('30000000', 6))

        // approve spending by pool
        await this.usdc.connect(users[1]).approve(this.mwV2.address, parseUnits('60000', 6))
        await this.usdc.connect(users[2]).approve(this.mwV2.address, parseUnits('90000', 6))
        await this.usdc.connect(users[3]).approve(this.mwV2.address, parseUnits('350000', 6))
        await this.usdc.connect(users[4]).approve(this.mwV2.address, parseUnits('1500000', 6))
        await this.usdc.connect(users[5]).approve(this.mwV2.address, parseUnits('18000000', 6))
        await this.usdc.connect(users[6]).approve(this.mwV2.address, parseUnits('30000000', 6))

        /// other tokens
        await this.usdt.transfer(users[7].address, parseUnits('50000000', 6))
        await this.usdt.connect(users[7]).approve(this.mwV2.address, parseUnits('50000000', 6))

        await this.dai.transfer(users[8].address, parseEther('40000000'))
        await this.dai.connect(users[8]).approve(this.mwV2.address, parseUnits('40000000', 18))

        await this.mim.transfer(users[9].address, parseEther('20000000'))
        await this.mim.connect(users[9]).approve(this.mwV2.address, parseUnits('20000000', 18))

        // add lp-tokens to the wombat master with correct weighing
        await this.mwV2.add('30', this.usdt.address, ethers.constants.AddressZero)
        await this.mwV2.add('30', this.usdc.address, ethers.constants.AddressZero)
        await this.mwV2.add('25', this.dai.address, ethers.constants.AddressZero)
        await this.mwV2.add('15', this.mim.address, ethers.constants.AddressZero)
        expect(await this.mwV2.totalAllocPoint()).to.be.equal(100)

        /// deposits
        // deposit full balance of each user into usdc pool
        await this.mwV2.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
        await this.mwV2.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
        await this.mwV2.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
        await this.mwV2.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
        await this.mwV2.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
        await this.mwV2.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

        // deposit for other tokens
        await this.mwV2.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
        await this.mwV2.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
        await this.mwV2.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
      }

      // migration to new pool
      await this.mw.connect(owner).updateEmissionRate(0)
      await this.mw.connect(owner).setNewMasterWombat(this.mwV2.address)
      await advanceTimeAndBlock(60 * 60 * 24 * 366) // advance a year

      // migrate usdc users[1]
      let [pendingTokens] = await this.mw.connect(users[1]).pendingTokens(1, users[1].address)
      let [amountPool1] = await this.mw.userInfo(1, users[1].address)
      let [amountPool0] = await this.mw.userInfo(0, users[1].address)
      await this.mw.connect(users[1]).migrate([1, 0])
      expect(pendingTokens).to.near(parseEther('1896'))
      expect(await this.wom.balanceOf(users[1].address)).to.near(parseEther('1896').mul(2)) // half tokens are from the old pool, half are from the new pool
      expect((await this.mwV2.userInfo(1, users[1].address)).amount).to.equal(amountPool1.mul(2))
      expect((await this.mwV2.userInfo(0, users[1].address)).amount).to.equal(amountPool0)

      // migrate usdc users[2]
      ;[pendingTokens] = await this.mw.connect(users[2]).pendingTokens(1, users[2].address)
      ;[amountPool1] = await this.mw.userInfo(1, users[2].address)
      ;[amountPool0] = await this.mw.userInfo(0, users[2].address)
      await this.mw.connect(users[2]).migrate([1, 0])
      expect(pendingTokens).to.near(BigNumber.from('15701805'))
      expect(await this.wom.balanceOf(users[2].address)).to.near(BigNumber.from('15701805').mul(2)) // half tokens are from the old pool, half are from the new pool
      expect((await this.mwV2.userInfo(1, users[2].address)).amount).to.equal(amountPool1.mul(2))
      expect((await this.mwV2.userInfo(0, users[2].address)).amount).to.equal(amountPool0)
    })
  })
})

after(async function () {
  await network.provider.request({
    method: 'hardhat_reset',
    params: [],
  })
})
