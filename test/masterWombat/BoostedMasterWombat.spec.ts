import { BigNumberish } from '@ethersproject/bignumber'
import { AddressZero } from '@ethersproject/constants'
import { parseEther, parseUnits } from '@ethersproject/units'
import { SignerWithAddress } from '@nomiclabs/hardhat-ethers/signers'
import chai, { expect } from 'chai'

import { BigNumber, Contract } from 'ethers'
import { ethers } from 'hardhat'
import {
  Asset,
  Asset__factory,
  BoostedMasterWombat,
  BoostedMasterWombat__factory,
  MockVeWom,
  MockVeWom__factory,
  TestERC20__factory,
  Voter,
  Voter__factory,
  WombatERC20,
  WombatERC20__factory,
} from '../../build/typechain'
import { near } from '../assertions/near'
import { roughlyNear } from '../assertions/roughlyNear'
import { advanceTimeAndBlock, latest, sqrt } from '../helpers'

chai.use(near)
chai.use(roughlyNear)

describe('BoostedMasterWombat', async function () {
  let owner: SignerWithAddress
  let users: SignerWithAddress[]

  let womPerSec: BigNumber

  let Wom: WombatERC20__factory
  let MasterWombat: BoostedMasterWombat__factory
  let TestERC20: TestERC20__factory
  let Asset: Asset__factory
  let VeWom: MockVeWom__factory
  let Voter: Voter__factory

  let wom: WombatERC20
  let mw: BoostedMasterWombat
  let voter: Voter
  let dummyAsset: Asset
  let veWom: MockVeWom

  let usdc: Contract
  let usdt: Contract
  let mim: Contract
  let dai: Contract

  before(async function () {
    ;[owner, ...users] = await ethers.getSigners()

    MasterWombat = (await ethers.getContractFactory('BoostedMasterWombat')) as BoostedMasterWombat__factory
    Wom = (await ethers.getContractFactory('WombatERC20')) as WombatERC20__factory
    TestERC20 = (await ethers.getContractFactory('TestERC20')) as TestERC20__factory
    Asset = (await ethers.getContractFactory('Asset')) as Asset__factory
    VeWom = (await ethers.getContractFactory('MockVeWom')) as MockVeWom__factory
    Voter = (await ethers.getContractFactory('Voter')) as Voter__factory

    // 80% of emissions generated by MasterWombat at 3,000,000 per month
    womPerSec = parseEther('0.9259259259259259')
  })

  const deployAsset = async (name: string, symbol: string, decimal: number, supply: BigNumberish) => {
    const token = await TestERC20.deploy(name, symbol, decimal, supply)
    await token.deployed()
    const asset = await Asset.deploy(token.address, 'LP-' + name, 'LP-' + symbol)
    await asset.deployed()

    // give permission to owner
    await asset.setPool(owner.address)
    await asset.addCash(supply)
    await asset.addLiability(supply)
    await asset.mint(owner.address, supply)

    return asset
  }

  beforeEach(async function () {
    wom = await Wom.deploy(owner.address, parseEther('1000000000'))
    await wom.deployed()

    // deploy master wombat
    mw = await MasterWombat.deploy()
    await mw.deployed()

    voter = await Voter.deploy()
    await voter.deployed()

    // deploy dommy token - 6 d.p.
    dummyAsset = await deployAsset('Dummy', 'DUMMY', 6, parseUnits('100', 6))

    // veWom - 18 d.p
    veWom = await VeWom.deploy()
    await veWom.deployed()

    await mw.initialize(
      wom.address,
      veWom.address,
      voter.address,
      1000 // 100% dialutng
    )

    await veWom.initialize(wom.address, mw.address)
    await veWom.connect(users[0]).faucet(parseEther('10000'))
    await veWom.setVoter(voter.address)

    const startTime = await latest()
    await voter.initialize(wom.address, veWom.address, womPerSec, startTime, startTime.add(86400 * 7), 0)

    await wom.transfer(voter.address, parseEther('100000000'))
  })

  describe('Master wombat Utils', async function () {
    beforeEach(async function () {
      await mw.updateEmissionPartition(1000) // 100% dialutng

      this.lp = await deployAsset('LPToken', 'LP', 18, parseEther('10000000000'))
      await this.lp.deployed()
      await this.lp.transfer(owner.address, parseEther('1000'))
      await this.lp.transfer(users[1].address, parseEther('1000'))
      await this.lp.transfer(users[2].address, parseEther('1000'))

      this.lp2 = await deployAsset('LPToken2', 'LP2', 6, parseUnits('10000000000', 6))
      await this.lp2.deployed()
      await this.lp2.transfer(owner.address, parseUnits('1000', 6))
      await this.lp2.transfer(users[1].address, parseUnits('1000', 6))
      await this.lp2.transfer(users[2].address, parseUnits('1000', 6))

      await voter.add(mw.address, this.lp.address, AddressZero)
      await voter.add(mw.address, this.lp2.address, AddressZero)
    })

    it('should pause and unpause', async function () {
      // Pause pool : expect to emit event and for state pause event to change
      const receipt1 = await mw.pause()
      expect(await mw.paused()).to.equal(true)
      await expect(receipt1).to.emit(mw, 'Paused').withArgs(owner.address)

      // Unpause pool : expect emit event and state change
      const receipt2 = await mw.unpause()
      expect(await mw.paused()).to.equal(false)

      await expect(receipt2).to.emit(mw, 'Unpaused').withArgs(owner.address)

      // restricts to owner
      await expect(mw.connect(users[0]).pause()).to.be.revertedWith('Ownable: caller is not the owner')
      await expect(mw.connect(users[0]).unpause()).to.be.revertedWith('Ownable: caller is not the owner')
    })

    it('withdraw full wom balance on emergencyWomWithdraw', async function () {
      // Should revert if called by not owner
      await expect(mw.connect(users[1]).emergencyWomWithdraw()).to.be.revertedWith('Ownable: caller is not the owner')

      // Emergency withdraw
      await wom.transfer(mw.address, parseEther('100'))
      const before = await wom.balanceOf(owner.address)
      await mw.emergencyWomWithdraw()
      const after = await wom.balanceOf(owner.address)

      expect(after.sub(before)).to.be.equal(parseEther('100'))
    })

    it('only veWom can call updateFactor', async function () {
      await expect(mw.updateFactor(users[1].address, parseEther('10'))).to.be.revertedWith(
        'MasterWombat: caller is not VeWom'
      )
      await expect(mw.updateFactor(owner.address, parseEther('10'))).to.be.revertedWith(
        'MasterWombat: caller is not VeWom'
      )

      await mw.setVeWom(owner.address)
      await expect(mw.updateFactor(users[1].address, parseEther('10'))).to.be.ok
    })

    it('should revert if the same lpToken is added into the pool', async function () {
      await mw.add(this.lp.address, AddressZero)

      await expect(mw.add(this.lp.address, AddressZero)).to.be.revertedWith('add: LP already added')
    })

    it('should set correct state variables womPerSec, veWom and emission repartition', async function () {
      // update veWom
      expect(await mw.veWom()).to.be.equal(veWom.address)
      const receipt1 = await mw.setVeWom(this.lp2.address)
      expect(await mw.veWom()).to.be.equal(this.lp2.address)

      expect(receipt1).to.emit(mw, 'UpdateVeWOM').withArgs(owner.address, veWom.address, this.lp2.address)

      // update emissions repartition
      expect(await mw.basePartition()).to.be.equal(1000)
      expect(await mw.boostedPartition()).to.be.equal(0)
    })

    it('should check rewarder added and set properly', async function () {
      // Try to add rewarder that is neither zero address or contract address
      await expect(mw.add(this.lp.address, users[1].address)).to.be.revertedWith(
        'add: boostedRewarder must be contract or zero'
      )

      await mw.add(this.lp.address, dummyAsset.address)

      // Try to set rewarder that is neither zero address or contract address
      await expect(mw.setRewarder('0', users[1].address)).to.be.revertedWith(
        'set: boostedRewarder must be contract or zero'
      )

      mw.setRewarder('0', dummyAsset.address)
    })

    it('should allow emergency withdraw from MasterWombat', async function () {
      await mw.add(this.lp.address, AddressZero)

      await this.lp.connect(users[1]).approve(mw.address, parseEther('1000'))

      await mw.connect(users[1]).deposit(0, parseEther('100'))

      expect(await this.lp.balanceOf(users[1].address)).to.equal(parseEther('900'))

      await mw.connect(users[1]).emergencyWithdraw(0)

      expect(await this.lp.balanceOf(users[1].address)).to.equal(parseEther('1000'))
    })

    it('emergency withdraw', async function () {
      // TODO: implement
    })
  })

  describe('[USDC Pool] Base pool only', async function () {
    beforeEach(async function () {
      await mw.updateEmissionPartition(1000) // 100% dialutng

      const emissionsPerSec = parseEther('0.3424657534')

      await voter.setWomPerSec(emissionsPerSec)

      // deploy usdc and the other tokens
      usdc = await deployAsset('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await usdc.deployed()

      usdt = await deployAsset('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await usdt.deployed()

      mim = await deployAsset('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await mim.deployed()

      dai = await deployAsset('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await dai.deployed()

      // credit users with usdc
      await usdc.transfer(users[1].address, parseUnits('60000', 6))
      await usdc.transfer(users[2].address, parseUnits('90000', 6))
      await usdc.transfer(users[3].address, parseUnits('350000', 6))
      await usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with veWom
      await veWom.connect(users[1]).faucet(parseEther('22000'))
      // await veWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no veWOM.
      await veWom.connect(users[3]).faucet(parseEther('3000'))
      await veWom.connect(users[4]).faucet(parseEther('128000'))
      await veWom.connect(users[5]).faucet(parseEther('5129300'))
      await veWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await usdc.connect(users[1]).approve(mw.address, parseUnits('60000', 6))
      await usdc.connect(users[2]).approve(mw.address, parseUnits('90000', 6))
      await usdc.connect(users[3]).approve(mw.address, parseUnits('350000', 6))
      await usdc.connect(users[4]).approve(mw.address, parseUnits('1500000', 6))
      await usdc.connect(users[5]).approve(mw.address, parseUnits('18000000', 6))
      await usdc.connect(users[6]).approve(mw.address, parseUnits('30000000', 6))

      /// other tokens
      await usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await usdt.connect(users[7]).approve(mw.address, parseUnits('50000000', 6))

      await dai.transfer(users[8].address, parseEther('40000000'))
      await dai.connect(users[8]).approve(mw.address, parseUnits('40000000', 18))

      await mim.transfer(users[9].address, parseEther('20000000'))
      await mim.connect(users[9]).approve(mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await mw.add(usdt.address, AddressZero)
      await mw.add(usdc.address, AddressZero)
      await mw.add(dai.address, AddressZero)
      await mw.add(mim.address, AddressZero)
      await voter.add(mw.address, usdt.address, AddressZero)
      await voter.add(mw.address, usdc.address, AddressZero)
      await voter.add(mw.address, dai.address, AddressZero)
      await voter.add(mw.address, mim.address, AddressZero)

      await voter
        .connect(users[0])
        .vote(
          [usdt.address, usdc.address, dai.address, mim.address],
          [parseEther('30'), parseEther('30'), parseEther('25'), parseEther('15')]
        )

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])
    })

    it('should give out wom when withdrawing', async function () {
      // deposit full balance of each user into usdc aggregate
      await mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
      await advanceTimeAndBlock(86400) // advance one day

      // withdraw usdc users[1]
      await mw.connect(users[1]).withdraw(1, parseUnits('60000', 6))
      expect(await usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('60000', 6))
      expect(await wom.balanceOf(users[1].address)).to.be.roughlyNear(parseEther('10.65'))

      // withdraw usdc user[2] forgot to stake his wom
      await mw.connect(users[2]).withdraw(1, parseUnits('90000', 6))
      expect(await usdc.balanceOf(users[2].address)).to.be.equal(parseUnits('90000', 6))
      expect(await wom.balanceOf(users[2].address)).to.roughlyNear(parseEther('15.97'))

      // withdraw usdc users[3]
      await mw.connect(users[3]).withdraw(1, parseUnits('350000', 6))
      expect(await usdc.balanceOf(users[3].address)).to.be.equal(parseUnits('350000', 6))
      expect(await wom.balanceOf(users[3].address)).to.roughlyNear(parseEther('62.13'))

      // withdraw usdc users[4]
      await mw.connect(users[4]).withdraw(1, parseUnits('1500000', 6))
      expect(await usdc.balanceOf(users[4].address)).to.be.equal(parseUnits('1500000', 6))
      expect(await wom.balanceOf(users[4].address)).to.roughlyNear(parseEther('266'))

      // withdraw usdc users[5]
      await mw.connect(users[5]).withdraw(1, parseUnits('18000000', 6))
      expect(await usdc.balanceOf(users[5].address)).to.be.equal(parseUnits('18000000', 6))
      expect(await wom.balanceOf(users[5].address)).to.roughlyNear(parseEther('3200'))

      // withdraw usdc users[6]
      await mw.connect(users[6]).withdraw(1, parseUnits('30000000', 6))
      expect(await usdc.balanceOf(users[6].address)).to.be.equal(parseUnits('30000000', 6))
      expect(await wom.balanceOf(users[6].address)).to.roughlyNear(parseEther('5326'))
    })
  })

  // TODO: fix test
  describe.skip('[USDC Pool] Non-dualuting pool only', async function () {
    beforeEach(async function () {
      await mw.updateEmissionPartition(0) // 100% non-dialutng

      const boostedWomPerSec = parseEther('0.5707762557077626')
      await voter.setWomPerSec(boostedWomPerSec)

      // deploy usdc and the other tokens
      usdc = await deployAsset('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await usdc.deployed()

      usdt = await deployAsset('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await usdt.deployed()

      mim = await deployAsset('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await mim.deployed()

      dai = await deployAsset('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await dai.deployed()

      // credit users with usdc
      await usdc.transfer(users[1].address, parseUnits('60000', 6))
      await usdc.transfer(users[2].address, parseUnits('90000', 6))
      await usdc.transfer(users[3].address, parseUnits('350000', 6))
      await usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockveWOM
      await veWom.connect(users[1]).faucet(parseEther('22000'))
      // await veWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no veWOM.
      await veWom.connect(users[3]).faucet(parseEther('3000'))
      await veWom.connect(users[4]).faucet(parseEther('128000'))
      await veWom.connect(users[5]).faucet(parseEther('5129300'))
      await veWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await usdc.connect(users[1]).approve(mw.address, parseUnits('60000', 6))
      await usdc.connect(users[2]).approve(mw.address, parseUnits('90000', 6))
      await usdc.connect(users[3]).approve(mw.address, parseUnits('350000', 6))
      await usdc.connect(users[4]).approve(mw.address, parseUnits('1500000', 6))
      await usdc.connect(users[5]).approve(mw.address, parseUnits('18000000', 6))
      await usdc.connect(users[6]).approve(mw.address, parseUnits('30000000', 6))

      // add lp-tokens to the wombat master with correct weighing
      await mw.add(usdt.address, AddressZero)
      await mw.add(usdc.address, AddressZero)
      await mw.add(dai.address, AddressZero)
      await mw.add(mim.address, AddressZero)
      await voter.add(mw.address, usdt.address, AddressZero)
      await voter.add(mw.address, usdc.address, AddressZero)
      await voter.add(mw.address, dai.address, AddressZero)
      await voter.add(mw.address, mim.address, AddressZero)

      await voter
        .connect(users[0])
        .vote(
          [usdt.address, usdc.address, dai.address, mim.address],
          [parseEther('30'), parseEther('30'), parseEther('25'), parseEther('15')]
        )

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])
    })

    it('should give out wom when withdrawing', async function () {
      // deposit full balance of each user into usdc aggregate
      await mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      await advanceTimeAndBlock(60 * 60 * 24) // advance one day

      // withdraw usdc users[1]
      await mw.connect(users[1]).withdraw(1, parseUnits('60000', 6))
      expect(await usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('60000', 6))
      expect(await wom.balanceOf(users[1].address)).to.be.roughlyNear(parseEther('17'))

      // withdraw usdc user[2] forgot to stake his wom so no boosted for him!
      await mw.connect(users[2]).withdraw(1, parseUnits('90000', 6))
      expect(await usdc.balanceOf(users[2].address)).to.be.equal(parseUnits('90000', 6))
      expect(await wom.balanceOf(users[2].address)).to.equal(parseEther('0'))

      // withdraw usdc users[3]
      await mw.connect(users[3]).withdraw(1, parseUnits('350000', 6))
      expect(await usdc.balanceOf(users[3].address)).to.be.equal(parseUnits('350000', 6))
      expect(await wom.balanceOf(users[3].address)).to.roughlyNear(parseEther('14.9'))

      // withdraw usdc users[4]
      await mw.connect(users[4]).withdraw(1, parseUnits('1500000', 6))
      expect(await usdc.balanceOf(users[4].address)).to.be.equal(parseUnits('1500000', 6))
      expect(await wom.balanceOf(users[4].address)).to.roughlyNear(parseEther('199'))

      // withdraw usdc users[5]
      await mw.connect(users[5]).withdraw(1, parseUnits('18000000', 6))
      expect(await usdc.balanceOf(users[5].address)).to.be.equal(parseUnits('18000000', 6))
      expect(await wom.balanceOf(users[5].address)).to.roughlyNear(parseEther('4384'))

      // withdraw usdc users[6]
      await mw.connect(users[6]).withdraw(1, parseUnits('30000000', 6))
      expect(await usdc.balanceOf(users[6].address)).to.be.equal(parseUnits('30000000', 6))
      expect(await wom.balanceOf(users[6].address)).to.roughlyNear(parseEther('10178'))

      // Withdraw using emergency withdraw from owner
      // Emergency withdraw
      const remainingBalance = await wom.balanceOf(mw.address)

      const before = await wom.balanceOf(owner.address)
      await mw.emergencyWomWithdraw()
      const after = await wom.balanceOf(owner.address)

      expect(after.sub(before)).to.be.equal(remainingBalance)
    })
  })

  describe.skip('[All pools] Base pool only', async function () {
    beforeEach(async function () {
      await mw.updateEmissionPartition(1000) // 100% dialutng

      const baseWomPerSec = parseEther('0.3424657534')
      await voter.setWomPerSec(baseWomPerSec)

      usdt = await deployAsset('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await usdt.deployed()
      await usdt.transfer(users[1].address, parseUnits('50000000', 6))
      await usdt.transfer(users[2].address, parseUnits('50000000', 6))

      await usdt.connect(users[1]).approve(mw.address, parseUnits('50000000', 6))
      await usdt.connect(users[2]).approve(mw.address, parseUnits('50000000', 6))

      usdc = await deployAsset('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await usdc.deployed()
      await usdc.transfer(users[1].address, parseUnits('50000000', 6))
      await usdc.transfer(users[2].address, parseUnits('50000000', 6))

      await usdc.connect(users[1]).approve(mw.address, parseUnits('50000000', 6))
      await usdc.connect(users[2]).approve(mw.address, parseUnits('50000000', 6))

      dai = await deployAsset('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await dai.deployed()
      await dai.transfer(users[1].address, parseEther('40000000'))
      await dai.transfer(users[2].address, parseEther('40000000'))

      await dai.connect(users[1]).approve(mw.address, parseUnits('40000000', 18))
      await dai.connect(users[2]).approve(mw.address, parseUnits('40000000', 18))

      mim = await deployAsset('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await mim.deployed()
      await mim.transfer(users[1].address, parseEther('20000000'))
      await mim.transfer(users[2].address, parseEther('20000000'))

      await mim.connect(users[1]).approve(mw.address, parseUnits('20000000', 18))
      await mim.connect(users[2]).approve(mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master
      await mw.add(usdt.address, AddressZero)
      await mw.add(usdc.address, AddressZero)
      await mw.add(dai.address, AddressZero)
      await mw.add(mim.address, AddressZero)
      await voter.add(mw.address, usdt.address, AddressZero)
      await voter.add(mw.address, usdc.address, AddressZero)
      await voter.add(mw.address, dai.address, AddressZero)
      await voter.add(mw.address, mim.address, AddressZero)

      await voter
        .connect(users[0])
        .vote(
          [usdt.address, usdc.address, dai.address, mim.address],
          [parseEther('30'), parseEther('30'), parseEther('25'), parseEther('15')]
        )

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])

      // deposit
      await mw.connect(users[1]).deposit(0, parseUnits('50000000', 6)) // usdt
      await mw.connect(users[1]).deposit(1, parseUnits('50000000', 6)) // usdc
      await mw.connect(users[1]).deposit(2, parseEther('40000000')) // dai
      await mw.connect(users[1]).deposit(3, parseEther('20000000')) // mim
    })

    it('should withdraw and claim wom', async function () {
      const randomAddress = '0xA73274A8186D9194c9816baA778392CB8a935926'

      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdt
      await mw.connect(users[1]).withdraw(0, parseUnits('50000000', 6))
      expect(await usdt.balanceOf(users[1].address)).to.be.equal(parseUnits('50000000', 6))
      let womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(parseEther('3239997.02031466542000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdt apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw usdc
      await mw.connect(users[1]).withdraw(1, parseUnits('50000000', 6))
      expect(await usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('50000000', 6))
      womBalance = await wom.balanceOf(users[1].address)
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('3239997.225794117460000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdc apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw dai
      await mw.connect(users[1]).withdraw(2, parseEther('40000000'))
      expect(await dai.balanceOf(users[1].address)).to.be.equal(parseUnits('40000000', 18))
      womBalance = await wom.balanceOf(users[1].address)
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('2699997.859360000000000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`dai apy : ${(2699997/40000000) * 100}`) //6.7499925

      // withdraw mim
      await mw.connect(users[1]).withdraw(3, parseEther('20000000'))
      womBalance = await wom.balanceOf(users[1].address)
      expect(await mim.balanceOf(users[1].address)).to.be.equal(parseUnits('20000000', 18))
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('1619998.818360000000000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`mim apy : ${((1619998)/20000000) * 100}`) //8.09999
    })

    it('should multiclaim from certain pools only', async function () {
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year
      const expectedYearlyRewardsPool12 = parseEther('3239997.02031466542000000').add(
        parseEther('3239997.225794117460000000')
      )

      const expectedYearlyRewardsPool34 = parseEther('2699997.859360000000000000').add(
        parseEther('1619998.818360000000000000')
      )

      // Using a callStatic in order to get the returned value of a non view function
      const [total, amounts, additionalRewards] = await mw.connect(users[1]).callStatic.multiClaim([0, 1])
      expect(total).to.near(expectedYearlyRewardsPool12)
      expect(amounts.length).to.eq(2)
      expect(additionalRewards.length).to.eq(2)

      // multiclaim pools 0 and 1
      await mw.connect(users[1]).multiClaim([0, 1])
      let womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewardsPool12)
      // console.log(womBalance)

      // multiclaim again, this time the other pools 3, 4
      await mw.connect(users[1]).multiClaim([2, 3])
      womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewardsPool34.add(expectedYearlyRewardsPool12))
    })

    it('should multiclaim from one pool only', async function () {
      const pids = [3]
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year
      const expectedYearlyRewards = parseEther('1619998.818360000000000000')

      const [pending] = await mw.pendingTokens(3, users[1].address)

      // multiclaim
      await mw.connect(users[1]).multiClaim(pids)
      const womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewards)
      expect(womBalance).to.near(pending)
      // console.log(womBalance)
    })

    it('should multiclaim from all pools', async function () {
      const pids = [0, 1, 2, 3]
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      const expectedYearlyRewards = parseEther('3239997.02031466542000000')
        .add(parseEther('3239997.225794117460000000'))
        .add(parseEther('2699997.859360000000000000'))
        .add(parseEther('1619998.818360000000000000'))

      // multiclaim
      await mw.connect(users[1]).multiClaim(pids)
      let womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewards)
      // console.log(womBalance)

      // ROUND 2
      // let another year pass
      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // multiclaim again
      await mw.connect(users[1]).multiClaim(pids)
      womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(expectedYearlyRewards.mul(2))
      // console.log(womBalance)
    })

    it('should claim with the deposit function', async function () {
      const randomAddress = '0xA73274A8186D9194c9816baA778392CB8a935926'

      // console.log(`Current timestamp before: ${(await latest()).toNumber()}`)

      await advanceTimeAndBlock(60 * 60 * 24 * 365) // advance one year

      // console.log(`Current timestamp after a year: ${(await latest()).toNumber()}`)

      // withdraw usdt
      await mw.connect(users[1]).deposit(0, 0)
      let womBalance = await wom.balanceOf(users[1].address)
      expect(womBalance).to.near(parseEther('3239997.020314665420000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdt apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw usdc
      await mw.connect(users[1]).deposit(1, 0)
      womBalance = await wom.balanceOf(users[1].address)
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('3239997.225794117460000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`usdc apy : ${(3239997/50000000) * 100}`) //6.479994

      // withdraw dai
      await mw.connect(users[1]).deposit(2, 0)
      womBalance = await wom.balanceOf(users[1].address)
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('2699997.859360000000000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`dai apy : ${(2699997/40000000) * 100}`) //6.7499925

      // withdraw mim
      await mw.connect(users[1]).deposit(3, 0)
      womBalance = await wom.balanceOf(users[1].address)
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('1619998.818360000000000000'))
      await wom.connect(users[1]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[1].address)).to.be.equal(0)
      // console.log(`mim apy : ${((1619998)/20000000) * 100}`) //8.09999
    })
  })

  describe('[All pools] Base + boosted pool', async function () {
    const randomAddress = '0x0B306BF915C4d645ff596e518fAf3F9669b97016'
    beforeEach(async function () {
      await mw.updateEmissionPartition(375) // 37.5% base => corresponds to 30% / 50%

      const emissionsPerSec = parseEther('0.91324200913242')
      await voter.setWomPerSec(emissionsPerSec)

      // deploy usdc and the other tokens
      usdc = await deployAsset('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await usdc.deployed()

      usdt = await deployAsset('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await usdt.deployed()

      mim = await deployAsset('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await mim.deployed()

      dai = await deployAsset('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await dai.deployed()

      // credit users with usdc
      await usdc.transfer(users[1].address, parseUnits('60000', 6))
      await usdc.transfer(users[2].address, parseUnits('90000', 6))
      await usdc.transfer(users[3].address, parseUnits('350000', 6))
      await usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockveWOM
      await veWom.connect(users[1]).faucet(parseEther('22000'))
      // await veWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no veWOM.
      await veWom.connect(users[3]).faucet(parseEther('3000'))
      await veWom.connect(users[4]).faucet(parseEther('128000'))
      await veWom.connect(users[5]).faucet(parseEther('5129300'))
      await veWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await usdc.connect(users[1]).approve(mw.address, parseUnits('60000', 6))
      await usdc.connect(users[2]).approve(mw.address, parseUnits('90000', 6))
      await usdc.connect(users[3]).approve(mw.address, parseUnits('350000', 6))
      await usdc.connect(users[4]).approve(mw.address, parseUnits('1500000', 6))
      await usdc.connect(users[5]).approve(mw.address, parseUnits('18000000', 6))
      await usdc.connect(users[6]).approve(mw.address, parseUnits('30000000', 6))

      /// other tokens
      await usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await usdt.connect(users[7]).approve(mw.address, parseUnits('50000000', 6))

      await dai.transfer(users[8].address, parseEther('40000000'))
      await dai.connect(users[8]).approve(mw.address, parseUnits('40000000', 18))

      await mim.transfer(users[9].address, parseEther('20000000'))
      await mim.connect(users[9]).approve(mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await mw.add(usdt.address, AddressZero)
      await mw.add(usdc.address, AddressZero)
      await mw.add(dai.address, AddressZero)
      await mw.add(mim.address, AddressZero)
      await voter.add(mw.address, usdt.address, AddressZero)
      await voter.add(mw.address, usdc.address, AddressZero)
      await voter.add(mw.address, dai.address, AddressZero)
      await voter.add(mw.address, mim.address, AddressZero)

      await voter
        .connect(users[0])
        .vote(
          [usdt.address, usdc.address, dai.address, mim.address],
          [parseEther('30'), parseEther('30'), parseEther('25'), parseEther('15')]
        )

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])

      /// deposits
      // deposit full balance of each user into usdc pool
      await mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
    })

    it('should withdraw and claim wom', async function () {
      await advanceTimeAndBlock(60 * 60 * 24) // advance one day

      // withdraw usdc users[1]
      let [pendingTokens] = await mw.connect(users[1]).pendingTokens(1, users[1].address)
      await mw.connect(users[1]).withdraw(1, parseUnits('60000', 6))
      expect(await usdc.balanceOf(users[1].address)).to.be.equal(parseUnits('60000', 6))
      expect(await wom.balanceOf(users[1].address)).to.roughlyNear(parseEther('27.2'))
      expect(await wom.balanceOf(users[1].address)).to.near(pendingTokens)

      // withdraw usdc user[2] forgot to stake his wom
      ;[pendingTokens] = await mw.connect(users[2]).pendingTokens(1, users[2].address)
      await mw.connect(users[2]).withdraw(1, parseUnits('90000', 6))
      expect(await usdc.balanceOf(users[2].address)).to.be.equal(parseUnits('90000', 6))
      expect(await wom.balanceOf(users[2].address)).to.roughlyNear(parseEther('15.97'))
      expect(await wom.balanceOf(users[2].address)).to.near(pendingTokens)

      // withdraw usdc users[3]
      ;[pendingTokens] = await mw.connect(users[3]).pendingTokens(1, users[3].address)
      await mw.connect(users[3]).withdraw(1, parseUnits('350000', 6))
      expect(await usdc.balanceOf(users[3].address)).to.be.equal(parseUnits('350000', 6))
      expect(await wom.balanceOf(users[3].address)).to.roughlyNear(parseEther('76.9'))
      expect(await wom.balanceOf(users[3].address)).to.near(pendingTokens)

      // withdraw usdc users[4]
      ;[pendingTokens] = await mw.connect(users[4]).pendingTokens(1, users[4].address)
      await mw.connect(users[4]).withdraw(1, parseUnits('1500000', 6))
      expect(await usdc.balanceOf(users[4].address)).to.be.equal(parseUnits('1500000', 6))
      expect(await wom.balanceOf(users[4].address)).to.roughlyNear(parseEther('466'))
      expect(await wom.balanceOf(users[4].address)).to.near(pendingTokens)

      // withdraw usdc users[5]
      ;[pendingTokens] = await mw.connect(users[5]).pendingTokens(1, users[5].address)
      await mw.connect(users[5]).withdraw(1, parseUnits('18000000', 6))
      expect(await usdc.balanceOf(users[5].address)).to.be.equal(parseUnits('18000000', 6))
      expect(await wom.balanceOf(users[5].address)).to.roughlyNear(parseEther('7580'))
      expect(await wom.balanceOf(users[5].address)).to.near(pendingTokens)

      // withdraw usdc users[6]
      ;[pendingTokens] = await mw.connect(users[6]).pendingTokens(1, users[6].address)
      await mw.connect(users[6]).withdraw(1, parseUnits('30000000', 6))
      expect(await usdc.balanceOf(users[6].address)).to.be.equal(parseUnits('30000000', 6))
      expect(await wom.balanceOf(users[6].address)).to.roughlyNear(parseEther('15504'))
      expect(await wom.balanceOf(users[6].address)).to.near(pendingTokens)

      /////

      // withdraw usdt
      ;[pendingTokens] = await mw.connect(users[7]).pendingTokens(0, users[7].address)
      await mw.connect(users[7]).withdraw(0, parseUnits('50000000', 6))
      expect(await usdt.balanceOf(users[7].address)).to.be.equal(parseUnits('50000000', 6))
      let womBalance = await wom.balanceOf(users[7].address)
      expect(womBalance).to.be.roughlyNear(parseEther('8876.075342465429424750'))
      expect(await wom.balanceOf(users[7].address)).to.near(pendingTokens)
      await wom.connect(users[7]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[7].address)).to.be.equal(0)

      // withdraw dai
      ;[pendingTokens] = await mw.connect(users[8]).pendingTokens(2, users[8].address)
      await mw.connect(users[8]).withdraw(2, parseEther('40000000'))
      expect(await dai.balanceOf(users[8].address)).to.be.equal(parseUnits('40000000', 18))
      womBalance = await wom.balanceOf(users[8].address)
      expect(womBalance).to.be.roughlyNear(parseEther('7397'))
      expect(await wom.balanceOf(users[8].address)).to.near(pendingTokens)
      await wom.connect(users[8]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[8].address)).to.be.equal(0)

      // withdraw mim
      ;[pendingTokens] = await mw.connect(users[9]).pendingTokens(3, users[9].address)
      await mw.connect(users[9]).withdraw(3, parseEther('20000000'))
      womBalance = await wom.balanceOf(users[9].address)
      expect(await mim.balanceOf(users[9].address)).to.be.equal(parseUnits('20000000', 18))
      expect(womBalance).to.be.roughlyNear(parseEther('4438'))
      expect(await wom.balanceOf(users[9].address)).to.near(pendingTokens)
      await wom.connect(users[9]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[9].address)).to.be.equal(0)
    })

    it('should claim with the deposit function', async function () {
      await advanceTimeAndBlock(60 * 60 * 24) // advance one day

      // withdraw usdc users[1]
      await mw.connect(users[1]).deposit(1, 0)
      expect(await wom.balanceOf(users[1].address)).to.roughlyNear(parseEther('27.2'))

      // withdraw usdc user[2] forgot to stake his wom
      await mw.connect(users[2]).deposit(1, 0)
      expect(await wom.balanceOf(users[2].address)).to.roughlyNear(parseEther('15.97'))

      // withdraw usdc users[3]
      await mw.connect(users[3]).deposit(1, 0)
      expect(await wom.balanceOf(users[3].address)).to.roughlyNear(parseEther('76.92'))

      // withdraw usdc users[4]
      await mw.connect(users[4]).deposit(1, 0)
      expect(await wom.balanceOf(users[4].address)).to.roughlyNear(parseEther('466.25'))

      // withdraw usdc users[5]
      await mw.connect(users[5]).deposit(1, 0)
      expect(await wom.balanceOf(users[5].address)).to.roughlyNear(parseEther('7580'))

      // withdraw usdc users[6]
      await mw.connect(users[6]).deposit(1, 0)
      expect(await wom.balanceOf(users[6].address)).to.roughlyNear(parseEther('15504'))

      /////

      // withdraw usdt
      await mw.connect(users[7]).deposit(0, 0)
      let womBalance = await wom.balanceOf(users[7].address)
      expect(womBalance).to.roughlyNear(parseEther('8876'))
      await wom.connect(users[7]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[7].address)).to.be.equal(0)

      // withdraw dai
      await mw.connect(users[8]).deposit(2, 0)
      womBalance = await wom.balanceOf(users[8].address)
      expect(womBalance).to.roughlyNear(parseEther('7397'))
      await wom.connect(users[8]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[8].address)).to.be.equal(0)

      // withdraw mim
      await mw.connect(users[9]).withdraw(3, 0)
      womBalance = await wom.balanceOf(users[9].address)
      expect(womBalance).to.roughlyNear(parseEther('4438'))
      await wom.connect(users[9]).transfer(randomAddress, womBalance) // burn the wom
      expect(await wom.balanceOf(users[9].address)).to.be.equal(0)
    })
  })

  describe('[All pools] veWOM integration test', async function () {
    beforeEach(async function () {
      await mw.updateEmissionPartition(375) // 37.5% base => corresponds to 30% / 50%

      const emissionsPerSec = parseEther('0.91324200913242')
      await voter.setWomPerSec(emissionsPerSec)

      // deploy usdc and the other tokens
      usdc = await deployAsset('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await usdc.deployed()

      usdt = await deployAsset('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await usdt.deployed()

      mim = await deployAsset('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await mim.deployed()

      dai = await deployAsset('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await dai.deployed()

      // credit users with usdc
      await usdc.transfer(users[1].address, parseUnits('60000', 6))
      await usdc.transfer(users[2].address, parseUnits('90000', 6))
      await usdc.transfer(users[3].address, parseUnits('350000', 6))
      await usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockveWOM
      await veWom.connect(users[1]).faucet(parseEther('22000'))
      // await veWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no veWOM.
      await veWom.connect(users[3]).faucet(parseEther('3000'))
      await veWom.connect(users[4]).faucet(parseEther('128000'))
      await veWom.connect(users[5]).faucet(parseEther('5129300'))
      await veWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await usdc.connect(users[1]).approve(mw.address, parseUnits('60000', 6))
      await usdc.connect(users[2]).approve(mw.address, parseUnits('90000', 6))
      await usdc.connect(users[3]).approve(mw.address, parseUnits('350000', 6))
      await usdc.connect(users[4]).approve(mw.address, parseUnits('1500000', 6))
      await usdc.connect(users[5]).approve(mw.address, parseUnits('18000000', 6))
      await usdc.connect(users[6]).approve(mw.address, parseUnits('30000000', 6))

      /// other tokens
      await usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await usdt.connect(users[7]).approve(mw.address, parseUnits('50000000', 6))

      await dai.transfer(users[8].address, parseEther('40000000'))
      await dai.connect(users[8]).approve(mw.address, parseUnits('40000000', 18))

      await mim.transfer(users[9].address, parseEther('20000000'))
      await mim.connect(users[9]).approve(mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await mw.add(usdt.address, AddressZero)
      await mw.add(usdc.address, AddressZero)
      await mw.add(dai.address, AddressZero)
      await mw.add(mim.address, AddressZero)
      await voter.add(mw.address, usdt.address, AddressZero)
      await voter.add(mw.address, usdc.address, AddressZero)
      await voter.add(mw.address, dai.address, AddressZero)
      await voter.add(mw.address, mim.address, AddressZero)

      await voter
        .connect(users[0])
        .vote(
          [usdt.address, usdc.address, dai.address, mim.address],
          [parseEther('30'), parseEther('30'), parseEther('25'), parseEther('15')]
        )

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])

      // NEW USER with 10k veWOM and 10k everything
      await veWom.connect(users[10]).faucet(parseEther('10000'))

      await usdt.transfer(users[10].address, parseUnits('10000', 6))
      await usdc.transfer(users[10].address, parseUnits('10000', 6))
      await dai.transfer(users[10].address, parseUnits('10000', 18))
      await mim.transfer(users[10].address, parseUnits('10000', 18))

      await usdt.connect(users[10]).approve(mw.address, parseUnits('10000', 6))
      await usdc.connect(users[10]).approve(mw.address, parseUnits('10000', 6))
      await dai.connect(users[10]).approve(mw.address, parseUnits('10000', 18))
      await mim.connect(users[10]).approve(mw.address, parseUnits('10000', 18))

      /// deposits
      // deposit full balance of each user into usdc pool
      await mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim

      // NEW USER deposits
      await mw.connect(users[10]).deposit(0, parseUnits('10000', 6)) // usdc
      await mw.connect(users[10]).deposit(1, parseUnits('10000', 6)) // usdt
      await mw.connect(users[10]).deposit(2, parseUnits('10000', 18)) // dai
      await mw.connect(users[10]).deposit(3, parseUnits('10000', 18)) // mim
    })

    it('should set & update factor and sumOfFactors correctly', async function () {
      /// usdt 0 / usdc 1 / dai 2 / mim 3
      /// === First part === ///
      /// (1) first check each pool sumOfFactors and users[10] factor per pool

      const user10Factors = new Map<number, BigNumberish>([
        [0, sqrt(parseUnits('10000', 6).mul(parseEther('10000')))],
        [1, sqrt(parseUnits('10000', 6).mul(parseEther('10000')))],
        [2, sqrt(parseUnits('10000', 18).mul(parseEther('10000')))],
        [3, sqrt(parseUnits('10000', 18).mul(parseEther('10000')))],
      ])

      // USDT
      let usdtPoolInfo = await mw.poolInfoV3(0)
      let userInfoUsdt = await mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(user10Factors.get(0))
      // users[7] has no veWOM so sumOfFactors is just users[10] factor
      expect(usdtPoolInfo.sumOfFactors).to.be.equal(user10Factors.get(0))

      // USDC
      let usdcPoolInfo = await mw.poolInfoV3(1)
      let userInfoUsdc = await mw.userInfo(1, users[10].address)
      let usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
        .add(sqrt(parseUnits('10000', 6).mul(parseEther('10000'))))
      expect(userInfoUsdc.factor).to.be.equal(user10Factors.get(1))
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      let daiPoolInfo = await mw.poolInfoV3(2)
      let userInfoDai = await mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(user10Factors.get(2))
      expect(daiPoolInfo.sumOfFactors).to.be.equal(user10Factors.get(2))

      // MIM
      let mimPoolInfo = await mw.poolInfoV3(3)
      let userInfoMim = await mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(user10Factors.get(3))
      expect(mimPoolInfo.sumOfFactors).to.be.equal(user10Factors.get(3))

      /// === Second part === ///
      /// (2) Mint veWOM and see if factor and sumOfFactors updates correctly for each pool
      // mint for users[7]
      await veWom.connect(users[7]).faucet(parseEther('10000'))
      // mint for users[10]
      await veWom.connect(users[10]).faucet(parseEther('10000'))

      // USDT
      usdtPoolInfo = await mw.poolInfoV3(0)
      userInfoUsdt = await mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(sqrt(parseUnits('10000', 6).mul(parseEther('20000'))))
      // users[7] now has veWOM so sumOfFactors is updated
      expect(usdtPoolInfo.sumOfFactors).to.be.equal(
        sqrt(parseUnits('50000000', 6).mul(parseEther('10000'))).add(
          sqrt(parseUnits('10000', 6).mul(parseEther('20000')))
        )
      )

      // USDC
      usdcPoolInfo = await mw.poolInfoV3(1)
      userInfoUsdc = await mw.userInfo(1, users[10].address)
      usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
        .add(sqrt(parseUnits('10000', 6).mul(parseEther('20000'))))
      expect(userInfoUsdc.factor).to.be.equal(sqrt(parseUnits('10000', 6).mul(parseEther('20000'))))
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      daiPoolInfo = await mw.poolInfoV3(2)
      userInfoDai = await mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))
      expect(daiPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))

      // MIM
      mimPoolInfo = await mw.poolInfoV3(3)
      userInfoMim = await mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))
      expect(mimPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('20000'))))

      /// === Third part === ///
      /// (3) then update vewom lock and see if factor and sumOfFactors updates correctly for each pool
      await veWom.connect(users[10]).update2(parseEther('10000'), parseEther('100000'), 365)

      // USDT
      usdtPoolInfo = await mw.poolInfoV3(0)
      userInfoUsdt = await mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(sqrt(parseUnits('10000', 6).mul(parseEther('110000'))))
      // users[7] now has vewom so sumOfFactors is updated
      expect(usdtPoolInfo.sumOfFactors).to.be.equal(
        sqrt(parseUnits('50000000', 6).mul(parseEther('10000'))).add(
          sqrt(parseUnits('10000', 6).mul(parseEther('110000')))
        )
      )

      // USDC
      usdcPoolInfo = await mw.poolInfoV3(1)
      userInfoUsdc = await mw.userInfo(1, users[10].address)
      usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
        .add(sqrt(parseUnits('10000', 6).mul(parseEther('110000'))))
      expect(userInfoUsdc.factor).to.be.equal(sqrt(parseUnits('10000', 6).mul(parseEther('110000'))))
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      daiPoolInfo = await mw.poolInfoV3(2)
      userInfoDai = await mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('110000'))))
      expect(daiPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('110000'))))

      // MIM
      mimPoolInfo = await mw.poolInfoV3(3)
      userInfoMim = await mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('110000'))))
      expect(mimPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('10000', 18).mul(parseEther('110000'))))

      /// === Fourth part === ///
      /// (4) then burn vewom and see if factor and sumOfFactors updates correctly for each pool
      await veWom.connect(users[10]).burn2(await veWom.balanceOf(users[10].address))

      // USDT
      usdtPoolInfo = await mw.poolInfoV3(0)
      userInfoUsdt = await mw.userInfo(0, users[10].address)
      expect(userInfoUsdt.factor).to.be.equal(0)
      expect((await mw.userInfo(0, users[7].address)).factor).to.be.equal(
        sqrt(parseUnits('50000000', 6).mul(parseEther('10000')))
      )

      expect(usdtPoolInfo.sumOfFactors).to.be.equal(sqrt(parseUnits('50000000', 6).mul(parseEther('10000'))))

      // USDC
      usdcPoolInfo = await mw.poolInfoV3(1)
      userInfoUsdc = await mw.userInfo(1, users[10].address)
      usdcSumOfFactors = sqrt(parseUnits('60000', 6).mul(parseEther('22000')))
        .add(sqrt(parseUnits('350000', 6).mul(parseEther('3000'))))
        .add(sqrt(parseUnits('1500000', 6).mul(parseEther('128000'))))
        .add(sqrt(parseUnits('18000000', 6).mul(parseEther('5129300'))))
        .add(sqrt(parseUnits('30000000', 6).mul(parseEther('16584200'))))
      expect(userInfoUsdc.factor).to.be.equal(0)
      expect(usdcPoolInfo.sumOfFactors).to.be.equal(usdcSumOfFactors)

      // DAI
      daiPoolInfo = await mw.poolInfoV3(2)
      userInfoDai = await mw.userInfo(2, users[10].address)
      expect(userInfoDai.factor).to.be.equal(0)
      expect(daiPoolInfo.sumOfFactors).to.be.equal(0)

      // MIM
      mimPoolInfo = await mw.poolInfoV3(3)
      userInfoMim = await mw.userInfo(3, users[10].address)
      expect(userInfoMim.factor).to.be.equal(0)
      expect(mimPoolInfo.sumOfFactors).to.be.equal(0)
    })
  })

  describe('[All pools] LP token Migration', async function () {
    beforeEach(async function () {
      await mw.updateEmissionPartition(375) // 37.5% base => corresponds to 30% / 50%

      const emissionsPerSec = parseEther('0.91324200913242')
      await voter.setWomPerSec(emissionsPerSec)

      // deploy usdc and the other tokens
      usdc = await deployAsset('USDC', 'LP-USDC', 6, parseUnits('10000000000', 6))
      await usdc.deployed()

      usdt = await deployAsset('USDT', 'LP-USDT', 6, parseUnits('10000000000', 6))
      await usdt.deployed()

      mim = await deployAsset('MIM', 'LP-MIM', 18, parseEther('10000000000')) // 10 b
      await mim.deployed()

      dai = await deployAsset('DAI', 'LP-DAI', 18, parseEther('10000000000')) // 10 b
      await dai.deployed()

      // credit users with usdc
      await usdc.transfer(users[1].address, parseUnits('60000', 6))
      await usdc.transfer(users[2].address, parseUnits('90000', 6))
      await usdc.transfer(users[3].address, parseUnits('350000', 6))
      await usdc.transfer(users[4].address, parseUnits('1500000', 6))
      await usdc.transfer(users[5].address, parseUnits('18000000', 6))
      await usdc.transfer(users[6].address, parseUnits('30000000', 6))

      // credit users with mockveWOM
      await veWom.connect(users[1]).faucet(parseEther('22000'))
      // await veWom.connect(users[2]).faucet(parseEther('0')) // users[2] has no veWOM.
      await veWom.connect(users[3]).faucet(parseEther('3000'))
      await veWom.connect(users[4]).faucet(parseEther('128000'))
      await veWom.connect(users[5]).faucet(parseEther('5129300'))
      await veWom.connect(users[6]).faucet(parseEther('16584200'))

      // approve spending by pool
      await usdc.connect(users[1]).approve(mw.address, parseUnits('60000', 6))
      await usdc.connect(users[2]).approve(mw.address, parseUnits('90000', 6))
      await usdc.connect(users[3]).approve(mw.address, parseUnits('350000', 6))
      await usdc.connect(users[4]).approve(mw.address, parseUnits('1500000', 6))
      await usdc.connect(users[5]).approve(mw.address, parseUnits('18000000', 6))
      await usdc.connect(users[6]).approve(mw.address, parseUnits('30000000', 6))

      /// other tokens
      await usdt.transfer(users[7].address, parseUnits('50000000', 6))
      await usdt.connect(users[7]).approve(mw.address, parseUnits('50000000', 6))

      await dai.transfer(users[8].address, parseEther('40000000'))
      await dai.connect(users[8]).approve(mw.address, parseUnits('40000000', 18))

      await mim.transfer(users[9].address, parseEther('20000000'))
      await mim.connect(users[9]).approve(mw.address, parseUnits('20000000', 18))

      // add lp-tokens to the wombat master with correct weighing
      await mw.add(usdt.address, AddressZero)
      await mw.add(usdc.address, AddressZero)
      await mw.add(dai.address, AddressZero)
      await mw.add(mim.address, AddressZero)
      await voter.add(mw.address, usdt.address, AddressZero)
      await voter.add(mw.address, usdc.address, AddressZero)
      await voter.add(mw.address, dai.address, AddressZero)
      await voter.add(mw.address, mim.address, AddressZero)

      await voter
        .connect(users[0])
        .vote(
          [usdt.address, usdc.address, dai.address, mim.address],
          [parseEther('30'), parseEther('30'), parseEther('25'), parseEther('15')]
        )

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])

      /// deposits
      // deposit full balance of each user into usdc pool
      await mw.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await mw.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await mw.connect(users[3]).deposit(1, parseUnits('350000', 6)) // usdc
      await mw.connect(users[4]).deposit(1, parseUnits('1500000', 6)) // usdc
      await mw.connect(users[5]).deposit(1, parseUnits('18000000', 6)) // usdc
      await mw.connect(users[6]).deposit(1, parseUnits('30000000', 6)) // usdc

      // deposit for other tokens
      await mw.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt
      await mw.connect(users[8]).deposit(2, parseUnits('40000000', 18)) // dai
      await mw.connect(users[9]).deposit(3, parseUnits('20000000', 18)) // mim
    })

    it('should revert if newMasterWombat not set', async function () {
      await expect(mw.connect(users[1]).migrate([1, 0])).to.be.revertedWith('to where?')
    })

    async function setUpNewMasterWombat(oldMW: Contract, newMW: Contract, voter: Contract) {
      await newMW.add(usdt.address, AddressZero)
      await newMW.add(usdc.address, AddressZero)
      await newMW.add(dai.address, AddressZero)
      await newMW.add(mim.address, AddressZero)
      await voter.setGauge(usdt.address, newMW.address)
      await voter.setGauge(usdc.address, newMW.address)
      await voter.setGauge(dai.address, newMW.address)
      await voter.setGauge(mim.address, newMW.address)
      await oldMW.setVoter(AddressZero)
      await oldMW.setNewMasterWombat(newMW.address)
    }

    it('user should be able to migrate once only ', async function () {
      await advanceTimeAndBlock(60 * 60 * 24) // advance one day
      const newMW = await MasterWombat.deploy()
      await mw.deployed()

      await newMW.initialize(
        wom.address,
        veWom.address,
        voter.address,
        500 // 50% base => corresponds to 40% / 40%
      )
      await setUpNewMasterWombat(mw, newMW, voter)

      const emissionsPerSec = parseEther('0.3424657534')
      voter.setWomPerSec(emissionsPerSec)

      // migrate usdc users[1]
      const [pendingTokens] = await mw.connect(users[1]).pendingTokens(1, users[1].address)
      const [amountPool1] = await mw.userInfo(1, users[1].address)
      const [amountPool0] = await mw.userInfo(0, users[1].address)
      await mw.connect(users[1]).migrate([1, 0])
      expect(await wom.balanceOf(users[1].address)).to.roughlyNear(parseEther('27.23'))
      expect(await wom.balanceOf(users[1].address)).to.near(pendingTokens)
      expect((await newMW.userInfo(1, users[1].address)).amount).to.equal(amountPool1)
      expect((await newMW.userInfo(0, users[1].address)).amount).to.equal(amountPool0)

      // nothing to migrate, nothing should be claimed and migrated
      await mw.connect(users[1]).migrate([1, 0])
      expect(await wom.balanceOf(users[1].address)).to.roughlyNear(parseEther('27.23'))
      expect(await wom.balanceOf(users[1].address)).to.near(pendingTokens)
      expect((await newMW.userInfo(1, users[1].address)).amount).to.equal(amountPool1)
      expect((await newMW.userInfo(0, users[1].address)).amount).to.equal(amountPool0)
    })

    it('should claim WOM before migrate()', async function () {
      await advanceTimeAndBlock(60 * 60 * 24) // advance one day

      const newMW = await MasterWombat.deploy()
      await mw.deployed()

      await newMW.initialize(
        wom.address,
        veWom.address,
        voter.address,
        500 // 50% base => corresponds to 40% / 40%
      )
      await setUpNewMasterWombat(mw, newMW, voter)

      const emissionsPerSec = parseEther('0.3424657534')
      voter.setWomPerSec(emissionsPerSec)

      // migrate usdc users[1]
      let [pendingTokens] = await mw.connect(users[1]).pendingTokens(1, users[1].address)
      let [amountPool1] = await mw.userInfo(1, users[1].address)
      let [amountPool0] = await mw.userInfo(0, users[1].address)
      await mw.connect(users[1]).migrate([1, 0])
      expect(await wom.balanceOf(users[1].address)).to.roughlyNear(parseEther('27.23'))
      expect(await wom.balanceOf(users[1].address)).to.near(pendingTokens)
      expect((await newMW.userInfo(1, users[1].address)).amount).to.equal(amountPool1)
      expect((await newMW.userInfo(0, users[1].address)).amount).to.equal(amountPool0)

      // migrate usdc users[2]
      ;[pendingTokens] = await mw.connect(users[2]).pendingTokens(1, users[2].address)
      ;[amountPool1] = await mw.userInfo(1, users[2].address)
      ;[amountPool0] = await mw.userInfo(0, users[2].address)
      await mw.connect(users[2]).migrate([1, 0])
      expect(await wom.balanceOf(users[2].address)).to.roughlyNear(parseEther('15.97'))
      expect(await wom.balanceOf(users[2].address)).to.near(pendingTokens)
      expect((await newMW.userInfo(1, users[2].address)).amount).to.equal(amountPool1)
      expect((await newMW.userInfo(0, users[2].address)).amount).to.equal(amountPool0)
    })

    it('should claim WOM in new MasterWombat pool during migration', async function () {
      await advanceTimeAndBlock(60 * 60 * 24) // advance one day

      const newMW = await MasterWombat.deploy()
      await mw.deployed()

      await newMW.initialize(
        wom.address,
        veWom.address,
        voter.address,
        500 // 50% base => corresponds to 40% / 40%
      )

      await setUpNewMasterWombat(mw, newMW, voter)

      const emissionsPerSec = parseEther('0.3424657534')
      voter.setWomPerSec(emissionsPerSec)
      await mw.multiClaim([0, 1, 2, 3])

      // wait for the next epoch start
      await advanceTimeAndBlock(86400 * 7)
      await mw.connect(users[0]).multiClaim([0, 1, 2, 3])

      // deposit into new mw
      await usdc.transfer(users[1].address, parseUnits('60000', 6))
      await usdc.transfer(users[2].address, parseUnits('90000', 6))
      await usdt.transfer(users[7].address, parseUnits('50000000', 6))

      await usdc.connect(users[1]).approve(newMW.address, parseUnits('60000', 6))
      await usdc.connect(users[2]).approve(newMW.address, parseUnits('90000', 6))
      await usdt.connect(users[7]).approve(newMW.address, parseUnits('50000000', 6))

      await newMW.connect(users[1]).deposit(1, parseUnits('60000', 6)) // usdc
      await newMW.connect(users[2]).deposit(1, parseUnits('90000', 6)) // usdc
      await newMW.connect(users[7]).deposit(0, parseUnits('50000000', 6)) // usdt

      await advanceTimeAndBlock(60 * 60 * 24) // advance one year

      // migrate usdc users[1]
      expect(await wom.balanceOf(users[1].address)).to.eq(0)
      await mw.connect(users[1]).migrate([1, 0])
      expect(await wom.balanceOf(users[1].address)).to.near(parseEther('8772'))
      expect((await newMW.userInfo(1, users[1].address)).amount).to.equal(parseUnits('120000', 6))
      expect((await newMW.userInfo(0, users[1].address)).amount).to.equal(0)

      // migrate usdc users[2]
      await mw.connect(users[2]).migrate([1, 0])
      expect(await wom.balanceOf(users[2].address)).to.near(parseEther('3789'))
      expect((await newMW.userInfo(1, users[2].address)).amount).to.equal(parseUnits('180000', 6))
      expect((await newMW.userInfo(0, users[2].address)).amount).to.equal(0)
    })
  })

  describe('notifyRewardAmount', function () {
    it('can be called from voter', async function () {
      await mw.connect(owner).setVoter(users[0].address)
      await expect(mw.connect(users[0]).notifyRewardAmount(AddressZero, 0)).to.be.revertedWith(
        'notifyRewardAmount: zero amount'
      )
    })

    it('cannot be called by owner', async function () {
      await expect(mw.connect(owner).notifyRewardAmount(AddressZero, 0)).to.be.revertedWith(
        'MasterWombat: caller is not Voter'
      )
    })

    it('cannot be called by user', async function () {
      await expect(mw.connect(users[0]).notifyRewardAmount(AddressZero, 0)).to.be.revertedWith(
        'MasterWombat: caller is not Voter'
      )
    })
  })
})
